<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Buevara</title>
  <icon>https://www.gravatar.com/avatar/b052651cafe03624e87490e24b7f70c4</icon>
  <subtitle>To hard!To work!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Buevara.github.io/"/>
  <updated>2018-05-20T04:04:53.582Z</updated>
  <id>http://Buevara.github.io/</id>
  
  <author>
    <name>Buevara</name>
    <email>brian7law@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法基础--背包问题(下篇)</title>
    <link href="http://Buevara.github.io/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%8B%E7%AF%87)/"/>
    <id>http://Buevara.github.io/2018/05/19/算法基础--背包问题(下篇)/</id>
    <published>2018-05-19T14:35:35.000Z</published>
    <updated>2018-05-20T04:04:53.582Z</updated>
    
    <content type="html"><![CDATA[<h1>算法基础--背包问题(下篇)</h1><p>背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。本篇是下篇：主要讨论求解满足背包最优的解决方案。</p><hr><h3>11. 0-1背包满足最大条件的最优方案问题</h3><blockquote><p>问题描述：m是背包的容量。n个物品，A表示物品重量，V表示物品的价值。 计算出的装入背包物品的最大价值和最优装入方案输出。例如：10, [4,2,5],[6,1,2]结果：81 0 1</p></blockquote><p>解题思路：</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##当计算完dp之后（求得了最优值之后），进行回溯，只回溯dp[x][m]</span></span><br><span class="line">        <span class="comment">### res表示最终的结果</span></span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackI</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        print(res)</span><br><span class="line">            </span><br><span class="line">a = Solution()</span><br><span class="line">a.backPackI(<span class="number">10</span>, [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure></p><hr><h3>12. 完全背包满足最大条件的最优方案问题</h3><blockquote><p>问题描述：m是背包的容量。n个物品，A表示物品重量，V表示物品的价值。每个物品可以用无限次， 计算出的装入背包物品的最大价值和最优装入方案输出。例如：m=11, A=[2,3,5,7], V=[1,5,2,4]结果： 16   [1, 3, 0, 0]</p></blockquote><p>解题思路：</p><blockquote></blockquote><p>和上面的题的思路是一样的，但是需要考虑：</p><ol><li>将完全背包转换为0-1背包，也就是改变A和V使用newMatrix函数</li><li>得到了res之后如何切分成原始A的数量用recover函数例如：A原始是:[2,3,5,7]newMatrix之后是:[2, 4, 6, 8, 10, 3, 6, 9, 5, 10, 7]res得到:[1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]recover之后：[1, 3, 0, 0]</li></ol><blockquote></blockquote><p>1.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a)</span>:</span></span><br><span class="line">        j = m//a</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend(A[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">            v.extend(V[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        A = a</span><br><span class="line">        print(A)</span><br><span class="line">        V = v</span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        print(res)</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><p>2.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil) $)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, k)</span>:</span></span><br><span class="line">        n = m//k</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ) </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        print(res)</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><p>结果： 16  [1, 3, 0, 0]</p><hr><h3>13. 多重背包满足最大条件的最优方案问题</h3><blockquote><p>问题描述：m是背包的容量。n个物品，A表示物品重量，V表示物品的价值,nk表示物品可用的次数， 计算出的装入背包物品的最大价值和最优装入方案输出。例如：m=11, A=[2,3,5,7], V=[1,5,2,4]结果： 16   [1, 3, 0, 0]</p></blockquote><p>解题思路：</p><p>和上题完全背包类似， 只是求$min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$ 或 $min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)$</p><p>1.时间复杂度O($m*(\sum_{i= 0}^{n-1}*min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a, k)</span>:</span></span><br><span class="line">        j = m//a</span><br><span class="line">        j = min(j, k)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i], nk[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend(A[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">            v.extend(V[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        A = a</span><br><span class="line">        print(A)</span><br><span class="line">        V = v</span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>2.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)) $)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a, k)</span>:</span></span><br><span class="line">        n = m//a</span><br><span class="line">        n = min(n, k)</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ) </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i], nk[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>结果：15   [0, 3, 0, 0]</p><hr><p>(全篇结束，如果有问题可以留言讨论)</p><p>参考文献：[1] https://www.kancloud.cn/kancloud/pack/70125[2] https://www.jiuzhang.com[3] https://blog.csdn.net/luoshengkim/article/details/X6514558</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;算法基础--背包问题(下篇)&lt;/h1&gt;
&lt;p&gt;背包问题是面试中非常常见的考点，今天整理一下。
由于篇幅过长，所以分成上、中、下三篇进行分析。
本篇是下篇：主要讨论求解满足背包最优的解决方案。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;11. 0-1背包满足最大条件的最优方案问题&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://Buevara.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包问题" scheme="http://Buevara.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--背包问题(中篇)</title>
    <link href="http://Buevara.github.io/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%AD%E7%AF%87)/"/>
    <id>http://Buevara.github.io/2018/05/19/算法基础--背包问题(中篇)/</id>
    <published>2018-05-19T10:15:35.000Z</published>
    <updated>2018-05-20T04:05:14.306Z</updated>
    
    <content type="html"><![CDATA[<h1>算法基础--背包问题(中篇)</h1><p>背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。本篇是中篇：主要讨论背包计数问题。</p><hr><h3>6. 0-1背包计数问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。每件大小是A[i]，每个物品只能用1次，问有多少种方法把它装满？例如： n=3， A=[1,2,4], m=11</p></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-7.png" alt="5.19-7"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackNumI</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">###dp[0][0] == 1 所以dp[1][0]...dp[x][0] 都等于1</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> range(x+<span class="number">1</span>):</span><br><span class="line">            dp[ii][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackNumI(<span class="number">12</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure></p><p>结果： 1  只有3+2+7=12 一种情况</p><hr><h3>7. 完全背包计数问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。每件大小是A[i]，每个物品能用无限次，问有多少种方法把它装满？例如： n=4， A=[2,3,5,7], m=11</p></blockquote><p>解题思路：</p><p>State:dp[i][j] 前i个物品正好放入j中的方案数量DP Function:dp[i][j] = dp[i - 1][j] + dp[i - 1][j - A[i-1] * 1] + dp[m - 1][j - A[i-1] * 2] + dp[i - 1][j - A[i-1] * 3] + ...Initialize:dp[0][0] = 1时间复杂度：O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackNumII</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]*v]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackNumII(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：4   分别为(1,1,1,1),(1,1,2),(2,2),(4)</p><hr><h3>8. 多重背包计数问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。每件大小是A[i]，每个物品只能用nk次，问有多少种方法把它装满？例如： n=3， A=[1,2,4], nk=[2,2,3], m=4</p></blockquote><p>解题思路：</p><p>时间复杂度：时间复杂度O($m*(\sum_{i= 0}^{n-1}*min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$)就是求：$min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor)$<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackNumII</span><span class="params">(self, m, A, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                k = min(k, nk[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]*v]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackNumII(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：3  分别为(1,1,2),(2,2),(4)</p><hr><h3>9. 0-1背包计数变形I的问题</h3><blockquote><p>问题描述：从一个数组中取k个数的和为target，求有多少种组合。假如数组是[1,2,3,4], k = 2, target = 5。那么有2种解：[1,4] 和 [2,3]。</p></blockquote><p>解题思路：state:f[i][j][t]前 i 个数中取 j 个数出来组成和为 t 的组合数目function:f[i][j][t] = f[i - 1][j][t] + f[i - 1][j - 1][t - a[i - 1]] (不包括第i 个数的时候组成t的情况 + 包括第i个数的时候组成t的情况)initialize:f[i][0][0] = 1result:f[n][k][target]</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newbackPackI</span><span class="params">(self, m, A, k)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)] </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x+<span class="number">1</span>):</span><br><span class="line">            print(i)</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">0</span>, m+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j][o] = dp[i<span class="number">-1</span>][j][o]</span><br><span class="line">                    <span class="keyword">if</span> o -A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                        dp[i][j][o] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>][o-A[i<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[x][k][m]</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.newbackPackI(<span class="number">5</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>结果：2</p><hr><h3>10. 完全背包计数变形I问题</h3><blockquote><p>问题描述：给定一个包含了一些数字的数组，和一个目标值，从数组里面取数做排列，使得排列的数字的和等于target。问有多少种排列方法。数字是阔以重复取出来的。比如给定数组[1, 2, 4]和target值4。那么能得到如下的组合。总共有6种，则返回6.</p></blockquote><p>结果：[1, 1, 1, 1][1, 1, 2][1, 2, 1][2, 1, 1][2, 2][4]</p><blockquote></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-8.png" alt="5.19-8"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newbackPackI</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> i-s &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] += dp[i-s]</span><br><span class="line">        <span class="keyword">return</span> dp[m]</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.newbackPackI(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：6</p><hr><p>(中篇结束，接下来的下篇将讨论求解满足背包最优的解决方案)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;算法基础--背包问题(中篇)&lt;/h1&gt;
&lt;p&gt;背包问题是面试中非常常见的考点，今天整理一下。
由于篇幅过长，所以分成上、中、下三篇进行分析。
本篇是中篇：主要讨论背包计数问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;6. 0-1背包计数问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://Buevara.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包问题" scheme="http://Buevara.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--背包问题(上篇)</title>
    <link href="http://Buevara.github.io/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%8A%E7%AF%87)/"/>
    <id>http://Buevara.github.io/2018/05/19/算法基础--背包问题(上篇)/</id>
    <published>2018-05-19T06:07:35.000Z</published>
    <updated>2018-05-20T04:05:31.851Z</updated>
    
    <content type="html"><![CDATA[<h1>算法基础--背包问题(上篇)</h1><p>背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。本篇是上篇：主要讨论背包问题的最优解问题。</p><hr><h3>1. 0-1背包问题</h3><blockquote><p>问题1描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]例如：m= 11 n=4 A=[2，3，5，7]</p></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-1.png" alt="5.19-1"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">###复杂度是O(n*m)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">###我们的物品设置从1开始，所以A[i-1]                </span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+A[i<span class="number">-1</span>])    </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br></pre></td></tr></table></figure></p><p>用1维数组：注意： j 的顺序是(m, 0, -1)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-A[i<span class="number">-1</span>]]+A[i<span class="number">-1</span>])  <span class="comment">###我们的物品设置从1开始，所以A[i-1]</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = dp[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m]</span><br></pre></td></tr></table></figure></p><blockquote><p>问题2描述：给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？例如：m= 11 n=4 A=[2，3，5，7]， V=[1, 5, 2, 4]</p></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-2.png" alt="5.19-2"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">###复杂度是O(n*m)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackI</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br></pre></td></tr></table></figure></p><hr><h3>2.完全背包问题（无限背包问题）</h3><blockquote><p>问题描述：有n种物品和一个容量为m的背包，每种物品都有无限件可用。第i种物品的空间是A[i]，价值是V[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。例如： n=4， A=[2,3,5,7], V = [1,5,4,2], m=11解题思路：1.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $)<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-3.png" alt="5.19-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                    tmp = [dp[i<span class="number">-1</span>][j-t*A[i<span class="number">-1</span>]]+t*V[i<span class="number">-1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>)]</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],max(tmp))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p></blockquote><p>变形一下，方便接下来的求最优方案：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a)</span>:</span></span><br><span class="line">        j = m//a</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            a.extend(A[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">            v.extend(V[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        A = a</span><br><span class="line">        V = v</span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                    tmp = [dp[i<span class="number">-1</span>][j-t*A[i<span class="number">-1</span>]]+t*V[i<span class="number">-1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>)]</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],max(tmp))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> (dp[x][m])</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>2.时间复杂度也为O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $) 但是换一种写法：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-4.png" alt="5.19-4"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    <span class="comment">### dp[i-1][j] 和 dp[i][j-A[i-1]]+V[i-1]</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>3.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil) $)<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-5.jpeg" alt="5.19-5"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, k)</span>:</span></span><br><span class="line">        n = m//k</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：16</p><hr><h3>3.多重背包问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。第i种物品最多有nk[i]件可用，每件大小是A[i]，价值是V[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。例如： n=4， A=[2,3,5,7], V = [1,5,4,2], nk = [2,3,4,5],  m=11</p></blockquote><p>解题思路：</p><ol><li>时间复杂度O($m*(\sum_{i= 0}^{n-1}*min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$)</li></ol><p>完全背包的变种， 求$min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackIII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                    k = min(k, nk[i<span class="number">-1</span>])</span><br><span class="line">                    tmp = [dp[i<span class="number">-1</span>][j-t*A[i<span class="number">-1</span>]]+t*V[i<span class="number">-1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>)]</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],max(tmp))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackIII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure></p><ol start="2"><li>时间复杂度为O($m*(\sum_{i= 0}^{n-1}*min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)) $)完全背包的变种， 求$min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)$</li></ol><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, k, nk)</span>:</span></span><br><span class="line">        n = m//k</span><br><span class="line">        n = min(nk, n)</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackIII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i], nk[i])</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackIII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：16</p><hr><h3>4.混合三种背包问题</h3><p>就是上面的三种问题的混合，具体不再赘述。</p><hr><h3>5.分组的背包问题</h3><p><img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-6.png" alt="5.19-6"></p><hr><p>(上篇结束，接下来的中篇将讨论背包计数问题)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;算法基础--背包问题(上篇)&lt;/h1&gt;
&lt;p&gt;背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。
本篇是上篇：主要讨论背包问题的最优解问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;1. 0-1背包问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://Buevara.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包问题" scheme="http://Buevara.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面经--知乎算法岗位</title>
    <link href="http://Buevara.github.io/2018/05/04/%E9%9D%A2%E7%BB%8F--%E7%9F%A5%E4%B9%8E%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/"/>
    <id>http://Buevara.github.io/2018/05/04/面经--知乎算法岗位/</id>
    <published>2018-05-04T02:18:35.000Z</published>
    <updated>2018-05-20T05:09:32.386Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--知乎算法岗位</h2><hr><h3>一面：</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.聊项目，xgboost和gbdt的差别？</p></li><li><p>3.验证集的作用？</p></li><li><p>4.什么是过拟合？如何解决过拟合？</p></li><li><p>5.L1正则和L2正则？</p></li><li><p>6.Droputout的含义？</p></li><li><p>7.BN层的含义？</p></li><li><ol start="8"><li>AUC,ROC的含义？</li></ol></li><li><ol start="9"><li>Inception和Resnet的区别？</li></ol></li><li><p>10.算法：</p><ol><li>旋转数组中的最小值？(剑指offer)</li><li>单词dog转换为tik,有词库voc。 我用了队列，他说不是最优的</li></ol></li></ul><hr><h3>二面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.项目中，xgboost和gbdt区别？</p></li><li><p>3.随机森林中的随机指的是什么？</p></li><li><p>4.gbdt的参数有哪些，如何调整？</p></li><li><p>5.树模型的深度和树的数量有什么关系？</p></li><li><p>6.BN层的作用？</p></li><li><p>7.会不会hive，hadoop？ 不会</p></li><li><p>8.词向量word2vec？ 没学过</p></li><li><p>9.协同过滤？</p></li><li><p>10.算法:</p><ol><li>无序数组 知道排序前和排序后的相对位置差的绝对值k，如何比快速排序的时间复杂度还低？ 堆排序，直接取k个初始，构建最小堆，每次取堆顶元素。</li><li>翻转链表的前x个元素？</li></ol></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--知乎算法岗位&lt;/h2&gt;
&lt;hr&gt;
&lt;h3&gt;一面：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.自我介绍.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.聊项目，xgboost和gbdt的差别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.验证集的作用？&lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--XGBOOST和GBDT的知识点整理</title>
    <link href="http://Buevara.github.io/2018/04/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--XGBOOST%E5%92%8CGBDT%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://Buevara.github.io/2018/04/24/机器学习--XGBOOST和GBDT的知识点整理/</id>
    <published>2018-04-24T12:28:35.000Z</published>
    <updated>2018-05-28T04:20:21.062Z</updated>
    
    <content type="html"><![CDATA[<h2>机器学习--XGBOOST和GBDT的知识点整理</h2><hr><h3>1.树模型缺失值</h3><p>树模型：如何处理缺失值：按照我自己的理解就是：在属性a下假如存在缺失值的话，在计算属性a下的信息增益或者信息增率时，把具有缺失值的元组去掉，把具有完整值的属性a代入计算，用去掉缺失值计算结果进行比较。</p><p>如图，假设有100个样本，针对属性A，有20个样本是缺失值。树模型处理缺失样本的时候，会先忽略属性A缺失的样本，然后采用某种属性选择度量（信息增益、增益率、基尼指数）对剩下的样本（现在有80个）进行分裂。假设将这80个样本分裂到图中的三个节点，三个节点分配到的样本数分别为30、25、25（称这个过程为过程一）。然后将属性A缺失的20个样本均加入到这三个节点中（称这个过程为过程二）。在过程一中加入节点的样本的权值均为1，而在过程二中加入节点的样本的权值为：该节点中属性A未缺失的样本数/父节点中属性A未缺失的样本数，如属性A缺失的样本添加到节点1之后的权重为 30/80 = 0.375。<img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-5.png" alt="4.18-5"></p><h3>2.为什么树模型不需要归一化特征？</h3><p>概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率。像svm、线性回归之类的最优化问题就需要归一化。决策树属于前者。</p><h3>3.xgboost</h3><p>https://blog.csdn.net/github_38414650/article/details/76061893</p><h3>4.为什么xgboost比gbdt更快？</h3><p>https://www.zhihu.com/question/41354392http://idatamining.net/blog/?p=1901</p><blockquote><p>1.可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。利用直方图的离散，找到最优的切分点。</p></blockquote><blockquote><p>2.既提供了单机多线程并行加速，也支持多机分布式加速。也就提供了若干种不同的并行建树的updater实现，按并行策略的不同，包括：<br>I). inter-feature exact parallelism （特征级精确并行）   II). inter-feature approximate parallelism（特征级近似并行，基于特征分bin计算，减少了枚举所有特征分裂点的开销）<br>III). intra-feature parallelism （特征内并行）IV). inter-node parallelism  （多机并行）</p></blockquote><blockquote><p>3.把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在 遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p><p>4.xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-13.png" alt="4.18-13"><img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-14.png" alt="4.18-14"><img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-15.png" alt="4.18-15"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;机器学习--XGBOOST和GBDT的知识点整理&lt;/h2&gt;
&lt;hr&gt;
&lt;h3&gt;1.树模型缺失值&lt;/h3&gt;
&lt;p&gt;树模型：
如何处理缺失值：
按照我自己的理解就是：在属性a下假如存在缺失值的话，在计算属性a下的信息增益或者信息增率时，把具有缺失值的元组去掉，把具有完整值的属
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Buevara.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="树模型" scheme="http://Buevara.github.io/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>面经--360机器学习算法岗位</title>
    <link href="http://Buevara.github.io/2018/04/24/%E9%9D%A2%E7%BB%8F--360%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%EF%BC%88%E4%BA%8C%E9%9D%A2%E6%8C%82%EF%BC%89/"/>
    <id>http://Buevara.github.io/2018/04/24/面经--360机器学习算法岗位（二面挂）/</id>
    <published>2018-04-24T12:28:35.000Z</published>
    <updated>2018-05-20T05:16:28.083Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--360机器学习算法岗位（二面挂）</h2><hr><h3>一面：</h3><ul><li>1.自我介绍.</li><li>2.问了所有的项目经历。</li><li>3.算法：大数据下找到两个人的共同好友？<a href="https://blog.csdn.net/u012808902/article/details/77513188" target="_blank" rel="noopener">澈彻策的博客</a><img src="https://github.com/Buevara/blog_img/raw/master/4.26/4.26-3.png" alt="4.26-3"></li></ul><hr><h3>二面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.SVM为什么特征需要归一化？</p></li></ul><p>首选，什么是归一化？什么是标准化？！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-1.png" target="_blank" rel="noopener">4.25-1</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-2.png" target="_blank" rel="noopener">4.25-2</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-3.png" target="_blank" rel="noopener">4.25-3</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-4.png" target="_blank" rel="noopener">4.25-4</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-5.png" target="_blank" rel="noopener">4.25-5</a></p><p>SVM的调参值？C和g： cost和gammagamma（或Epsilon ε）---不敏感损失函数的参数，gamma越大，支持向量越少，gamma值越小，支持向量越多，RBF宽度越大</p><p>C 惩罚系数，C过大或过小，泛化能力变差！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-6.png" target="_blank" rel="noopener">4.25-6</a><a href="https://blog.csdn.net/wusecaiyun/article/details/49681431" target="_blank" rel="noopener">参考链接</a>https://www.zhihu.com/question/20455227</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--360机器学习算法岗位（二面挂）&lt;/h2&gt;
&lt;hr&gt;
&lt;h3&gt;一面：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.自我介绍.&lt;/li&gt;
&lt;li&gt;2.问了所有的项目经历。&lt;/li&gt;
&lt;li&gt;3.算法：
大数据下找到两个人的共同好友？
&lt;a href=&quot;https://blog.
      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经--阿里巴巴机器学习岗位</title>
    <link href="http://Buevara.github.io/2018/04/19/%E9%9D%A2%E7%BB%8F--%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%EF%BC%88%E4%B8%80%E9%9D%A2%E6%8C%82%EF%BC%89/"/>
    <id>http://Buevara.github.io/2018/04/19/面经--阿里巴巴机器学习算法岗位（一面挂）/</id>
    <published>2018-04-19T13:28:35.000Z</published>
    <updated>2018-05-20T04:48:01.647Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--阿里巴巴机器学习算法岗位（一面挂）</h2><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.问了发表过的安全相关的论文（完全没复习，什么也不会）。</p></li><li><p>3.项目上用到了迁移学习，问迁移学习的原理是什么。（一脸懵逼）迁移学习是把一个领域（即源领域）的知识，迁移到另外一个领域（即目标领域），使得目标领域能够取得更好的学习效果。通常，源领域数据量充足，而目标领域数据量较小，迁移学习需要将在数据量充足的情况下学习到的知识，迁移到数据量小的新环境中。</p></li><li><p>4.cnn的激活函数有什么？为什么sigmod函数会出现梯度消失和梯度爆炸？<a href="https://zhuanlan.zhihu.com/p/25631496" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-3.png" alt="4.19-3"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-4.png" alt="4.19-4"></p></li></ul><blockquote><p>解决方案：<a href="https://blog.csdn.net/qq_25737169/article/details/78847691" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-5.png" alt="4.19-5"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-6.png" alt="4.19-6"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-7.png" alt="4.19-7"></p></blockquote><ul><li><p>5.为什么不用传统的三层网络，而使用CNN呢？为什么不能用DNN一直加深去做？<a href="https://www.zhihu.com/question/34681168" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-1.png" alt="4.19-1"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-2.png" alt="4.19-2"></p></li><li><p>6.假如有一张人脸照片，用CNN的卷积提取流程？由浅层特征到深层特征，从纹理，到局部再到全图。每个卷积和只提取一种特征。</p></li><li><p>7.项目中的创新点？</p></li><li><p>8.cnn的权值共享是什么意思？<a href="https://www.zhihu.com/question/47158818" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a></p></li><li><p>9.逻辑斯蒂回归为什么用sigmod函数而不用其他的函数？<img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-8.png" alt="4.19-8"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-9.png" alt="4.19-9"></p></li></ul><p>一面结束，二十分钟。很多问题没有答上来，真的感觉有些东西从来没想过，面试官认为我的项目工作量过小，基础方面需要加强。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--阿里巴巴机器学习算法岗位（一面挂）&lt;/h2&gt;
&lt;hr&gt;
&lt;h3&gt;一面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.自我介绍.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.问了发表过的安全相关的论文（完全没复习，什么也不会）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.项目上
      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--动态规划解决子序列、子串问题</title>
    <link href="http://Buevara.github.io/2018/04/17/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%81%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://Buevara.github.io/2018/04/17/算法基础--动态规划解决子序列、子串问题/</id>
    <published>2018-04-17T04:57:35.000Z</published>
    <updated>2018-05-19T05:28:25.104Z</updated>
    
    <content type="html"><![CDATA[<h1>解决最长公共子序列和最长公共子串</h1><p>子串是连续的，子序列是相对位置不变，可以连续，也可以不连续。</p><hr><h2>最长公共子序列问题（Longest Common Subsequence,LCS）</h2><p>下面的字符串也可以是数组，本质上都一样。</p><hr><h3>1.求解两个字符串的最长公共子序列的长度</h3><blockquote><p>问题描述：给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB,则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p></blockquote><p>解题思路：假设字符串分别为x,y,从x和y的最后字母开始看:</p><blockquote><ul><li>x[i]==y[j],则c[i][j] = c[i-1][j-1]c[i,j]表示：(x1,x2....xi) 和 (y1,y2...yj 的最长公共子序列的长度)</li><li>x[i]!=y[j],则分为两种情况c[i-1][j] 和c[i][j-1]我们取 max(c[i-1][j],c[i][j-1])</li></ul></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-1.png" alt="4.17-1">解释一下为什么i或j==0，为什么c[i][j] =0:c[0,j]表示字符串1的长度是0，字符串2的长度是j，这两个字符串的最长公共子序列的长度是？当然是0喽。。。因为，字符串1 根本就没有嘛。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-2.png" alt="4.17-2"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    m = len(y)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n][m]</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="string">'bdcaba'</span>,<span class="string">'abcbdab'</span>))</span><br></pre></td></tr></table></figure></p><p>结果是：4</p><hr><h3>2.求解两个字符串的所有最长公共子序列</h3><p>求一个最长子序列的问题是这个问题的简化版，所以不单独考虑了。</p><p>我们用第一种方法得到了dp这个二维数组，记录了最长子串的长度，我们现在用dp来递归寻找所有最大公共子序列。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-3.png" alt="4.17-3"></p><blockquote><p>输出一个最长公共子序列并不难（网上很多相关代码），难点在于输出所有的最长公共子序列，因为 LCS 通常不唯一。总之，我们需要在动态规划表上进行回溯 —— 从dp[m][n]，即右下角的格子，开始进行判断：</p><ol><li>如果格子dp[i][j]对应的x[i-1] ==y[j-1]，则把这个字符放入LCS中，并跳入dp[i-1][j-1]中继续进行判断；</li><li>如果格子dp[i][j]对应的 x[i-1] ≠ y[j-1]，则比较dp[i-1][j]和dp[i][j-1]的值，跳入值较大的格子继续进行判断；</li><li>如果出现dp[i-1][j]等于dp[i][j-1]的情况，说明最长公共子序列有多个，故两边都要进行回溯,这里用到递归。</li></ol><blockquote><ol start="4"><li>直到 i 或 j 小于等于零为止，倒序输出 LCS 。</li></ol></blockquote></blockquote><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        n = len(x)</span><br><span class="line">        m = len(y)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self, x,y,dp, i, j, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i ==<span class="number">0</span> <span class="keyword">or</span> j ==<span class="number">0</span>:</span><br><span class="line">            self.res.append(tmp[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">            self.printf(x, y, dp, i<span class="number">-1</span>, j<span class="number">-1</span>, tmp+x[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] &gt; dp[i][j<span class="number">-1</span>]:</span><br><span class="line">                self.printf(x, y, dp, i<span class="number">-1</span>, j, tmp)</span><br><span class="line">            <span class="keyword">elif</span> dp[i<span class="number">-1</span>][j] &lt; dp[i][j<span class="number">-1</span>]:</span><br><span class="line">                self.printf(x, y, dp, i, j<span class="number">-1</span>, tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.printf(x, y, dp, i, j<span class="number">-1</span>, tmp)</span><br><span class="line">                self.printf(x, y, dp, i<span class="number">-1</span>, j, tmp)</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longest</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        dp = self.solve(x, y)</span><br><span class="line">        self.res = []</span><br><span class="line">        self.printf(x, y, dp, len(x), len(y), <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.longest(<span class="string">'dbcab'</span>,<span class="string">'cdab'</span>))</span><br></pre></td></tr></table></figure></p><p>结果：['cab', 'dab']</p><hr><h2>最长公共子串问题</h2><p>下面的字符串也可以是数组，本质上都一样。</p><hr><h3>1.求解两个字符串的最长公共子串的长度</h3><p>子串是子序列的一个特殊形式，所以比求子序列更简单。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-4.png" alt="4.17-4"><img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-5.jpeg" alt="4.17-5"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    m = len(y)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="string">'abc'</span>,<span class="string">'adbc'</span>))</span><br></pre></td></tr></table></figure></p><p>结果：2</p><hr><h3>2.求解两个字符串的所有最长公共子串</h3><p>就是找下图中从最大子串长度开始斜向上到1的对应字符相加，进行翻转就是结果。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-5.jpeg" alt="4.17-5"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    m = len(y)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    maxx =  max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == maxx:</span><br><span class="line">                tmp.append([i, j])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> tmp:</span><br><span class="line">        t = <span class="string">''</span></span><br><span class="line">        i,j = k[<span class="number">0</span>],k[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> j<span class="number">-1</span>&gt;=<span class="number">0</span>) <span class="keyword">and</span> x[i<span class="number">-1</span>]==y[j<span class="number">-1</span>]:</span><br><span class="line">            t += x[i<span class="number">-1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        res.append(t)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="string">'adcbc'</span>,<span class="string">'adbc'</span>))</span><br></pre></td></tr></table></figure></p><p>结果：['bc', 'ad']</p><hr><p>拓展：</p><h3>1.最长增长子序列</h3><p><a href="https://www.nowcoder.com/questionTerminal/585d46a1447b4064b749f08c2ab9ce66" target="_blank" rel="noopener">原题链接</a></p><blockquote><p>题目：给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6，7，1，2，8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.</p></blockquote><p>思路：解法1：最长公共子序列法这个问题可以转换为最长公共子序列问题。如例子中的数组A{5，6， 7， 1， 2， 8}，则我们排序该数组得到数组A‘{1， 2， 5， 6， 7，8}，然后找出数组A和A’的最长公共子序列即可。</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">代码请参考第一道题</span><br></pre></td></tr></table></figure></p><p>解法2：动态规划法（时间复杂度O(N^2))</p><blockquote><p>设长度为N的数组为{a0，a1,a2,...an-1)，建立dp二维矩阵如例子所示：假设数组a =[2,1,4,6],建立二维dp数组</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-6.jpg" alt="4.17-6">结果是3，分别是：[1,4,6]和[2,4,6]</p><blockquote><p>1.dp[i]<a href="i=0%EF%BC%8C1%EF%BC%8C2%EF%BC%8C3%EF%BC%8Clen(a)-1">i</a>代表着以i结尾的递增数组的长度,初始值dp[0][0] = 12.如果a[i] &gt; a[j]（i&gt;j）,说明以a[i]结尾的递增数列的一个子集（有可能不是最长的）可以是[...,a[j],a[i]],所以dp[i][j] = dp[j][j] + 13.如果a[i] &lt;= a[j]（i&gt;j）,说明a[i]结尾的递增数列肯定不包含a[j]，故dp[i][j] = 04.dp[i][i]的值是dp[i]这一列的最大值5.找到所有dp[i]<a href="i=0%EF%BC%8C1%EF%BC%8C2%EF%BC%8C3%EF%BC%8Clen(a)-1">i</a>中的最大值，就是最长的长度</p></blockquote><p>代码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongest</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        n = len(a)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> a[i] &gt; a[j]:</span><br><span class="line">                    dp[i][j] = dp[j][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            tmp = max(dp[i][:])</span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][i] = tmp</span><br><span class="line"></span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="comment">### maxx是dp中最大的值</span></span><br><span class="line">        maxx = max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">        <span class="keyword">return</span> maxx</span><br><span class="line">        self.xunzhao(a, dp, location, [a[location]])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">b = AscentSequence()</span><br><span class="line"></span><br><span class="line">print(b.findLongest([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure></p><hr><h3>2.最长增长子序列中所有增长子序列</h3><p>解题思路：和上面一样找到最大的长度的步骤是一样的，用动态规划，但是需要进行递归查找最大长度递增的子序列，需要注意，结果不止一个。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-7.jpeg" alt="4.17-7"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xunzhao</span><span class="params">(self, a, dp, end, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dp[end][end] == <span class="number">1</span>:</span><br><span class="line">            self.res.append(tmp[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(end):</span><br><span class="line">            <span class="keyword">if</span> dp[end][i] == dp[end][end] <span class="keyword">and</span> a[i] &lt; a[end]:</span><br><span class="line">                self.xunzhao(a, dp, i, tmp+[a[i]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongest</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        n = len(a)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> a[i] &gt; a[j]:</span><br><span class="line">                    dp[i][j] = dp[j][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            tmp = max(dp[i][:])</span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][i] = tmp</span><br><span class="line"></span><br><span class="line">        <span class="comment">### maxx是dp中最大的值</span></span><br><span class="line">        maxx = max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">        print(maxx)</span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            <span class="keyword">if</span> dp[i][i] == maxx:</span><br><span class="line">                location = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.xunzhao(a, dp, location, [a[location]])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">b = AscentSequence()</span><br><span class="line"></span><br><span class="line">print(b.findLongest([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;解决最长公共子序列和最长公共子串&lt;/h1&gt;
&lt;p&gt;子串是连续的，子序列是相对位置不变，可以连续，也可以不连续。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;最长公共子序列问题（Longest Common Subsequence,LCS）&lt;/h2&gt;
&lt;p&gt;下面的字符串也可以是数组，本质上都
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://Buevara.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>面经--京东机器学习算法岗位</title>
    <link href="http://Buevara.github.io/2018/04/16/%E9%9D%A2%E7%BB%8F--%E4%BA%AC%E4%B8%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/"/>
    <id>http://Buevara.github.io/2018/04/16/面经--京东机器学习算法岗位/</id>
    <published>2018-04-16T08:01:30.000Z</published>
    <updated>2018-05-20T05:18:09.904Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--京东机器学习算法岗位</h2><hr><p>共三面，两轮技术面，一轮hr面。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.python装饰器，迭代器，生成器。</p></li><li><p>3.tensorflow高级操作的包，我回答contrib，他问我这个包的含义是什么,我不会，面试官告诉我是开源贡献者提供的方法。</p></li><li><p>4.机器学习的基础模型都有哪些？ 我答svm和logistic，讲了原理和损失函数的具体含义。</p></li><li><p>5.Inception和ResNet网络结构的特点和差别。</p></li><li><p>6.Hive和Hadoop了解吗？ 回答不了解，尴尬......</p></li><li><p>7.问我为什么没过六级，......  这个问题太难了，我也不知道怎么回答，后来面试官说没事，随口一问，吓死我了。</p></li><li><p>8.他问我有什么想问他的，我问了他所在的部门的具体工作，面试官说主要是做模型建立，给各个深度学习相关的部门提供底层模型支持。</p></li></ul><p>一面结束，二十分钟。（太短了，很不适应）</p><hr><h3>二面</h3><ul><li><p>1.问了我知不知道应聘的部门是做什么的，感不感兴趣。</p></li><li><p>2.迄今为止最印象深刻的项目。</p></li><li><p>3.详细介绍了问了我简历上的三个项目。</p></li><li><p>4.最后给我一些建议，应该完善技术栈，会用并且知道怎么用，需要linux的命令经验，hadoop和spark需要会一些。</p></li></ul><p>二面结束，还是二十分钟，面试官很nice，人很好。</p><hr><h3>hr面</h3><ul><li><p>1.自我介绍。</p></li><li><p>2.为什么从通信工程转到信息安全。</p></li><li><p>3.项目中遇到的最大的困难。</p></li><li><p>4.你能给你们部门带来什么。</p></li></ul><p>hr面结束，还是二十分钟，第一次电话面试比较紧张。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--京东机器学习算法岗位&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;共三面，两轮技术面，一轮hr面。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;一面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.自我介绍.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.python装饰器，迭代器，生成器。&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习--Inception和Xception网络</title>
    <link href="http://Buevara.github.io/2018/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--Inception%E5%92%8CXception%E7%BD%91%E7%BB%9C/"/>
    <id>http://Buevara.github.io/2018/04/15/深度学习--Inception和Xception网络/</id>
    <published>2018-04-15T10:41:05.000Z</published>
    <updated>2018-05-20T06:42:36.830Z</updated>
    
    <content type="html"><![CDATA[<h2>深度学习--Inception和Xception网络</h2><p>整理了一些Inception和Xception网络的资料：</p><blockquote><p>1.<a href="https://blog.csdn.net/yuanchheneducn/article/details/53045551" target="_blank" rel="noopener">Inception v1到v4演变</a></p><p>2.<a href="https://blog.csdn.net/u010402786/article/details/52433324" target="_blank" rel="noopener">网络模型中Inception的作用与结构全解析</a></p><p>3.<a href="https://www.jianshu.com/p/0583f1ba068c" target="_blank" rel="noopener">卷积神经网络工作原理研究-Inception结构研究</a></p><p>4.<a href="https://blog.csdn.net/xbinworld/article/details/61674836" target="_blank" rel="noopener">卷积神经网络结构变化</a></p><p>5.<a href="https://zhuanlan.zhihu.com/p/33999416" target="_blank" rel="noopener">关于「Inception」和「Xception」的那些事</a></p><p>6.<a href="https://blog.csdn.net/lynnandwei/article/details/53736235" target="_blank" rel="noopener">inception V4 与resnet</a></p><p>7.<a href="https://blog.csdn.net/u014380165/article/details/75142710" target="_blank" rel="noopener">Xception算法详解</a></p><p>8.<a href="https://zhuanlan.zhihu.com/p/29367273" target="_blank" rel="noopener">CNN卷及操作详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;深度学习--Inception和Xception网络&lt;/h2&gt;
&lt;p&gt;整理了一些Inception和Xception网络的资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.&lt;a href=&quot;https://blog.csdn.net/yuanchheneducn/art
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://Buevara.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="网络模型" scheme="http://Buevara.github.io/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--模型的评价指标</title>
    <link href="http://Buevara.github.io/2018/04/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>http://Buevara.github.io/2018/04/13/机器学习--模型的评价指标/</id>
    <published>2018-04-13T11:45:15.000Z</published>
    <updated>2018-04-14T04:11:39.857Z</updated>
    
    <content type="html"><![CDATA[<h2>分为回归问题的评价指标和分类问题的评价指标。</h2><blockquote><p>回归问题的评价指标：</p><blockquote><p>1.SSE（误差平方和）</p><p>2.MAE(Mean Absolute Error) 平均绝对误差</p><p>3.MSE(Mean Square Error)<strong>平均平方差/均方误差是回归任务最常用的性能度量</strong>4.MAPE</p><p>5.R-square（决定系数）</p><p>6.Adjusted R-Square (校正决定系数）</p></blockquote></blockquote><blockquote><p>分类问题的评价指标：</p></blockquote><blockquote><blockquote><p>1.accuarcy 正确率</p><p>2.precision,recall,F1-score,F-score,ROC-AUC曲线</p></blockquote></blockquote><hr><h3>回归问题</h3><h4>1.SSE（误差平方和）</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-1.png" alt="4.14-1"></p><h4>2.MAE(Mean Absolute Error) 平均绝对误差</h4><p>$$  MAE=\frac{1}{n}\sum_{n}^{i=1}|Y_predict-Y_actual|  $$</p><h4>3.MSE(Mean Square Error)</h4><p>$$ MSE=\frac{1}{n}\sum_{n}<sup>{i=1}(Y_predict-Y_actual)</sup>{2} $$</p><h4>4.MAPE</h4><p>全称是Mean Absolute Percentage Error。$$ MAPE=\frac{100}{n}\sum_{n}^{i=1}|\frac{Y_actual-Y_predict}{Y_actual}| $$</p><h4>5.R-square（决定系数）</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-2.png" alt="4.14-2"></p><h4>6.Adjusted R-Square (校正决定系数）</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-3.png" alt="4.14-3"></p><hr><h3>回归问题</h3><h4>1.accuarcy 正确率</h4><p>$$ accuarcy=\frac{N_true}{N_sum} $$$N_true$是分类正确的数量$N_sum$是训练样本的总数量</p><h4>2.precision,recall,F1-score,F-score,ROC-AUC曲线</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-4.png" alt="4.14-4"><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-5.png" alt="4.14-5"></p><p>ROC曲线如下图，横轴是负正率，纵轴是真正率。<img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-6.png" alt="4.14-6">如何绘制曲线呢？</p><blockquote></blockquote><p>真实标签y=[1,1,0,0,1]分类器预测=[0.5,0.6,0.55,0.4,0.7]我们选择阈值0.1，那么5个样本被分进1类，选择0.3，结果是一样的，选择0.45，那么只有样本4分为0类，其余都是1类，得到类别，我们就能计算真正率和负正率，就可以画图了。</p><blockquote></blockquote><p>理解ROC曲线：</p><p>ROC曲线图中的四个点和一条线。第一个点，(0,1)，即FPR=0, TPR=1，这意味着FN（false negative）=0，并且FP（false positive）=0。这是一个完美的分类器，它将所有的样本都正确分类。第二个点，(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。第三个点，(0,0)，即FPR=TPR=0，即FP（false positive）=TP（true positive）=0，可以发现该分类器预测所有的样本都为负样本（negative）。类似的，第四个点（1,1），分类器实际上预测所有的样本都为正样本。经过以上的分析，我们可以断言，ROC曲线越接近左上角，该分类器的性能越好。</p><p>对于ROC曲线图中的y=x上的点。这条对角线上的点其实表示的是一个采用随机猜测策略的分类器的结果，例如(0.5,0.5)，表示该分类器随机对于一半的样本猜测其为正样本，另外一半的样本为负样本。</p><hr><p>参考相关博客和资料：</p><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;分为回归问题的评价指标和分类问题的评价指标。&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;回归问题的评价指标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.SSE（误差平方和）&lt;/p&gt;
&lt;p&gt;2.MAE(Mean Absolute Error) 平均绝对误差&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Buevara.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="评价指标" scheme="http://Buevara.github.io/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>面经--58同城算法岗位、优信二手车数据挖掘岗位</title>
    <link href="http://Buevara.github.io/2018/04/12/%E9%9D%A2%E7%BB%8F--58%E5%90%8C%E5%9F%8E%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%E3%80%81%E4%BC%98%E4%BF%A1%E4%BA%8C%E6%89%8B%E8%BD%A6%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%B2%97%E4%BD%8D/"/>
    <id>http://Buevara.github.io/2018/04/12/面经--58同城算法岗位、优信二手车数据挖掘岗位/</id>
    <published>2018-04-12T09:06:30.000Z</published>
    <updated>2018-05-20T04:48:48.257Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--58同城算法岗位、优信二手车数据挖掘岗位</h2><p>58同城两面挂，优信二手车一面结束，所以放在一起整理。</p><hr><h3>58同城算法岗位</h3><h4>一面</h4><ul><li><p>1.自我介绍。</p></li><li><p>2.自己的海量数据处理项目。</p></li><li><p>3.kaggle项目中用到的神经网络的不同，和更优秀的模型的差别。</p></li><li><p>4.机器学习的基础模型中svm的原理，线性不可分时还可以用svm吗？可以，用高斯核函数，无限延伸到无穷维度。</p></li><li><p>5.bagging和boosting的区别？</p></li></ul><p><a href="https://buevara.github.io/2018/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/">答案点击这里</a></p><p>一面结束，四十分钟左右，其中聊项目比较多，没问算法。</p><hr><h4>二面（电话面试）</h4><ul><li><p>1.自我介绍。</p></li><li><p>2.介绍自己最深刻的项目。（京东店铺销量预测大赛）</p></li><li><p>3.XGBOOST和GBDT的不同，为什么XGBOOST复杂度高却比GBDT更快？<a href="https://blog.csdn.net/wolf963/article/details/78508858" target="_blank" rel="noopener">参考答案1</a><a href="https://www.zhihu.com/question/41354392" target="_blank" rel="noopener">参考答案2</a></p></li><li><p>4.python装饰器？</p></li></ul><p>装饰器：拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。<a href="https://blog.csdn.net/u010358168/article/details/77773199" target="_blank" rel="noopener">参考答案</a></p><p>拓展：迭代器：它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。迭代器就是其他语言里的iterator，主要是实现了<code>__iter__</code>，以及和其他语言对应的<code>__next__</code>方法。</p><p>生成器：是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。生成器generator是python特有的，iterator的一个子类，（我理解）主要目的是方便你来实现一个iterator。</p><ul><li>5.为什么树模型不需要归一化特征？</li></ul><p><strong>概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率。像svm、线性回归之类的最优化问题就需要归一化。决策树属于前者。</strong></p><ul><li>6.SVM用于回归模型如何解释？</li></ul><p><a href="http://blog.sina.com.cn/s/blog_62970c250102xfzj.html" target="_blank" rel="noopener">参考答案</a></p><ul><li>7.L1正则化和L2正则化特征，为什么？为什么L1和等值线的交点在坐标轴上的概率最大？<a href="https://www.cnblogs.com/heguanyou/p/7688344.html" target="_blank" rel="noopener">参考答案</a><a href="https://www.zhihu.com/question/23536142" target="_blank" rel="noopener">参考答案</a><a href="https://blog.csdn.net/zhuxiaodong030/article/details/54408786" target="_blank" rel="noopener">参考答案</a><img src="https://github.com/Buevara/blog_img/raw/master/4.16/4.16-3.png" alt="4.16-3"></li><li>8.MySql数据库引擎是什么？</li></ul><p>二面结束，三十分钟左右，其中聊项目比较多，基础知识问的都只能说出一些，再往深我没想过，面试官说希望对模型有更深的理解。</p><hr><h3>优信二手车数据挖掘岗位</h3><h4>一面</h4><ul><li><p>1.自我介绍。</p></li><li><p>2.自己JD店铺预测项目如何做的，用了什么模型？SVM,XGBOOST,GBDT...</p></li><li><p>3.SVM有哪些超参数？惩罚系数C和核函数选择和核函数的$ \sigma $。</p></li></ul><blockquote><p>使用SVM时，有两个点要注意：若使用核函数，一定要对Feature做Feature Scaling(Normalization)若训练集m太小，但Feature数量n很大，则训练数据不足以拟合复杂的非线性模型，这种情况下只能用linear-kernel（就是fi=xi）不能用高斯核</p></blockquote><p>来自于 Andrew NG. machine learning class at coursera</p><ul><li>4.logistic回归的超参数？只有一个：学习率</li><li>5.针对于回归问题的评价指标？当时没答上来，应该是mse，mae，决定系数等等。</li><li>5.AUC和ROC怎么求？概念不是很清晰，没推导出来</li><li>6.bagging和boosting的区别？</li><li>7.bagging和boosting分别对模型的偏差和方差有着怎样的影响？简单来说，就是bagging方差降低了，偏差高。boosting是对偏差进行拟合，降低了偏差，方差会随着训练增大。</li></ul><p><img src="https://github.com/Buevara/blog_img/raw/master/4.16/4.16-1.png" alt="4.16-1"></p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.16/4.16-2.png" alt="4.16-2">图片和结论来自于<a href="https://blog.csdn.net/shenxiaoming77/article/details/53894973" target="_blank" rel="noopener">Michael_Shentu的博客</a></p><ul><li>时间复杂度和空间复杂度的含义？</li><li>算法题：</li><li>1.求一个字符串的所有子集？ 简单递归思想</li><li>2.二分查找</li></ul><p>一面结束，五十分钟，答的一般，有两个问题不会。一面结束让我等一下，进行二面，过了一会说二面不在，到时候再约面试，我说ok。晚上hr小姐姐给我打电话，本来以为要约二面，结果和我说不用了，等下个月通知，一脸懵逼。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--58同城算法岗位、优信二手车数据挖掘岗位&lt;/h2&gt;
&lt;p&gt;58同城两面挂，优信二手车一面结束，所以放在一起整理。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;58同城算法岗位&lt;/h3&gt;
&lt;h4&gt;一面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.自我介绍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--最大似然估计（MLE）和最大后验概率（MAP）</title>
    <link href="http://Buevara.github.io/2018/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%88MLE%EF%BC%89%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%EF%BC%88MAP%EF%BC%89/"/>
    <id>http://Buevara.github.io/2018/04/09/机器学习--最大似然估计（MLE）和最大后验概率（MAP）/</id>
    <published>2018-04-09T08:12:13.000Z</published>
    <updated>2018-04-09T10:15:00.264Z</updated>
    
    <content type="html"><![CDATA[<h2>最大似然估计（MLE）和最大后验概率（MAP）</h2><hr><h3>最大似然估计 MLE</h3><p>给定一堆数据，加入我们知道他是从某一分部中随机取出来的。可是我们并不知道这个分布具体的参，即“模型已定，参数未知”。例如，我们知道这个分布是正态分布，但是不知道均值和方差；或者是二项分布，但是不知道均值。最大似然估计（MLE，Maximum Likelihood Estimation）就可以用来估计模型的参数。MLE的目标是找出一组参数，使得模型产生出观测数据的概率最大：$ \arg max _{ \mu}(p(X; \mu)) $</p><p>其中$ p(X; \mu) $ 就是似然函数，表示在参数$ \mu $ 下出现观测数据的概率。我们假设每个观测数据是独立的，那么有<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-1.png" alt="4.9-1"></p><p>为了寻求方便，一般对目标取$ log $。所以最优化似然函数等于最优化对数似然函数：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-2.png" alt="4.9-2">举一个抛硬币的简单例子。 现在有一个正反面不是很匀称的硬币，如果正面朝上记为正，方面朝上记为反，抛10次的结果如下：</p><p>正正正反反反正反正反</p><p>很显然这个概率是0.5。现在我们用MLE的思想去求解它。我们知道每次抛硬币都是一次二项分布，设正面朝上的概率是$ \mu $，那么似然函数为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-3.png" alt="4.9-3">x=1表示正面朝上，x=0表示方面朝上。那么有：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-4.png" alt="4.9-4">求导：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-5.png" alt="4.9-5">令导数为0，很容易得到：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-6.png" alt="4.9-6">也就是0.5。</p><hr><h3>最大后验概率  MAP</h3><p>以上求MLE   求得是找出一组能够使似然函数最大的参数，即$ \arg max <em>{ \mu}(p(X; \mu)) $ 。现在问题稍微复杂一点，假如这个参数$ \mu $ 有一个先验概率呢？比如说，在上面抛硬币的例子，假如我们的经验告诉我们，硬币一般都是均匀的，也就是$ \mu $=0.5的可能性最大，$ \mu $=0.2的可能性比较小，那么参数如何估计呢？这就是MAP要考虑的问题。MAP优化的是一个后验概率，即给定了观测值后是的$ \mu $最大的：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-7.png" alt="4.9-7">把上式根据贝叶斯公式展开：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-8.png" alt="4.9-8">我们可以看出第一项$ p(X; \mu) $ 就是似然函数，第二项$ p(\mu) $就是先验知识。取$ log $之后就是：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-9.png" alt="4.9-9">回到刚才的抛硬币的例子，假设参数$ \mu $有一个先验估计，他服从$ Beta $分布，即：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-10.png" alt="4.9-10">而每次抛硬币仍然服从二项分布：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-11.png" alt="4.9-11">那么目标函数的导数是：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-12.png" alt="4.9-12">求导的第一项已经在MLE中给出了，第二项为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-13.png" alt="4.9-13">令导数为0，求解为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-14.png" alt="4.9-14">其中，$ n</em>{H} $表示正面朝上的次数。这里看以看出，MLE与MAP的不同之处在于，MAP的结果多了一些先验分布的参数。</p><hr><h3>补充知识： Beta分布</h3><p>Beat分布是一种常见的先验分布，它形状由两个参数控制，定义域为[0,1]<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-15.png" alt="4.9-15"></p><p>Beta分布的最大值是x等于$ \frac{\alpha -1}{\alpha +\beta -2} $的时候：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-16.png" alt="4.9-16">所以在抛硬币中，如果先验知识是说硬币是匀称的，那么就让$ \alpha = \beta  $。但是很显然即使它们相等，它两的值也对最终结果很有影响。它两的值越大，表示偏离匀称的可能性越小：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-17.png" alt="4.9-17"></p><hr><p>文章转自 <a href="http://www.cnblogs.com/sylvanas2012/p/5058065.html" target="_blank" rel="noopener">Leavingseason的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;最大似然估计（MLE）和最大后验概率（MAP）&lt;/h2&gt;
&lt;hr&gt;
&lt;h3&gt;最大似然估计 MLE&lt;/h3&gt;
&lt;p&gt;给定一堆数据，加入我们知道他是从某一分部中随机取出来的。可是我们并不知道这个分布具体的参，即“模型已定，参数未知”。例如，我们知道这个分布是正态分布，但是不知
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Buevara.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="统计学习方法" scheme="http://Buevara.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--模型融合方法</title>
    <link href="http://Buevara.github.io/2018/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/"/>
    <id>http://Buevara.github.io/2018/04/05/机器学习--模型融合方法/</id>
    <published>2018-04-05T03:32:11.000Z</published>
    <updated>2018-04-11T12:38:34.723Z</updated>
    
    <content type="html"><![CDATA[<h3>Ensemble Learning--模型融合</h3><p>含义：通过对多个单模型融合以提升整体性能。</p><blockquote><p>1.Voting</p><p>2.Averaging</p><p>3.Ranking</p><p>4.Bagging</p><p>5.Boosting</p><p>6.Bagging和Boosting的区别</p><p>7.Stacking</p><p>8.Blending</p><p>9.Stacking和Blending的区别</p></blockquote><h4>模型的融合条件</h4><ul><li>[x]  Base Model 之间的相关性要尽可能的小。这就是为什么非 Tree-based Model 往往表现不是最好但还是要将它们包括在 Ensemble 里面的原因。Ensemble 的 Diversity 越大，最终 Model 的 Bias 就越低。</li><li>[x]  Base Model 之间的性能表现不能差距太大。这其实是一个 Trade-off，在实际中很有可能表现相近的 Model 只有寥寥几个而且它们之间相关性还不低。但是实践告诉我们即使在这种情况下 Ensemble 还是能大幅提高成绩。</li></ul><hr><h4>1.Voting</h4><blockquote><p>投票即为，投票多者为最终的结果。用于分类问题：多个模型投票（当然可以设置权重）。最终投票数最多的类为最终被预测的类。</p></blockquote><hr><h4>2.Averaging</h4><blockquote><p>Averaging即所有预测器的结果平均。</p></blockquote><ul><li>[ ] 回归问题，直接取平均值作为最终的预测值。（也可以使用加权平均）</li><li>[ ] 分类问题，直接将模型的预测概率做平均。（or 加权）</li></ul><p>加权平均，其公式如下：<img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-2.png" alt="4.11-2"></p><p>其中n表示模型的个数， $Weighti$表示该模型权重，$Pi$表示模型i的预测概率值。</p><hr><h4>3.Ranking</h4><blockquote><p>Rank的思想其实和Averaging一致，但Rank是把排名做平均，对于例如一些评价指标有效，如：AUC指标。</p></blockquote><p>具体公式如下：</p><p>加权平均，其公式如下：</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-3.png" alt="4.11-3"></p><p>其中n表示模型的个数， $Weighti$表示该模型权重，所有权重相同表示平均融合。$Ranki$表示样本在第i个模型中的升序排名。它可以较快的利用排名融合多个模型之间的差异，而不需要加权融合概率。</p><hr><h4>4.Bagging</h4><blockquote><p>1.同一个学习算法在来自同一分布的多个不同的训练数据集上训练得到的模型偏差可能较大，即模型的方差（variance）较大，为了解决这个问题，可以综合多个模型的输出结果，对于回归问题可以取平均值，对于分类问题可以采取多数投票的方法。这就是Bagging的核心思想。2.Bagging(Bootstrap Aggregation)是常用的统计学习方法，其综合的基本学习器可以是各种弱学习器。3.使用训练数据的不同随机子集来训练每个 Base Model，最后每个 Base Model 权重相同，分类问题进行投票，回归问题平均。经典算法：随机森林</p></blockquote><p>注意： <strong>有放回抽样</strong> （可能抽到重复的样本）</p><p>Bagging是将弱分类器组装成强分类器的方法。具体步骤：A）从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</p><p>B）每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</p><p>C）对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</p><p>如图所示：</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-4.png" alt="4.11-4"></p><p>要想综合N个弱分类器（决策树）的结果，我们需要采样N个训练数据集，在实际应用中获取N个训练数据集往往不现实，BootStrap 采样提供了一种有效的解决方法。采用这样的方式解决了获取N个服从同一分布的原始数据集不现实的问题，而且在可接受程度上，可以认为Bootstrap 采样方式不影响到模型的准确性（以方差来衡量），即可以等价于使用N个不同的原始数据集。</p><blockquote><p>Bagging较单棵决策树来说，降低了<em>方差</em>，但由于将多棵决策树的结果进行了平均，这损失了模型的可解释性。</p></blockquote><hr><h4>5.boosting</h4><p>Boosting是一种迭代的方法，每一次训练会更关心上一次被分错的样本。</p><blockquote><p>核心问题：1）在每一轮如何改变训练数据的权值或概率分布？</p></blockquote><blockquote><p>通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</p></blockquote><blockquote><p>2）通过什么方式来组合弱分类器？</p></blockquote><blockquote><p>通过加法模型将弱分类器进行线性组合</p></blockquote><p>经典算法：</p><p>AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</p><p>提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。</p><hr><h4>6.Bagging和Boosting的区别</h4><p>Bagging和Boosting的区别：</p><p>1）样本选择上：</p><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><p>2）样例权重：</p><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><p>3）预测函数：</p><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><p>4）并行计算：</p><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><blockquote><p>这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。</p></blockquote><blockquote><p>下面是将决策树与这些算法框架进行结合所得到的新的算法：</p></blockquote><blockquote><p>1）Bagging + 决策树 = 随机森林</p></blockquote><blockquote><p>2）AdaBoost + 决策树 = 提升树</p></blockquote><blockquote><p>3）Gradient Boosting + 决策树 = GBDT</p></blockquote><hr><h4>7.Stacking</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-5.jpg" alt="4.11-5">图片来自于<a href="https://zhuanlan.zhihu.com/p/26890738" target="_blank" rel="noopener">Leon的知乎专栏</a>个人认为很想深度学习模型中的xception网络，这里不同的模型相当于xception中不同尺寸的卷积，进行不同特征的提取。</p><p>我们在这里只考虑两层的stacking，多层同理。</p><p>假设第一层的用到3个模型model1，model2，model3，第二层一个模型model4。步骤：</p><ol><li>首先先将训练集分成用K fold</li><li>用model对K-1折进行训练，剩下1折进行预测，一共可以的到K个（训练数据总数n/k）个结果，我们将其按照顺序排好，第1个n/k对应K折中的1折。reshape成为一个n*1的预测结果（我们可以把他考虑成为特征向量）</li><li>针对于预测集，K折交叉验证的每一次，都要对预测集进行一次预测，一共可以得到K*（预测集总数m），我们将其取平均，得到一个1*m的预测label（也可以看做是预测集的特征向量）</li><li>对于第一层的每个模型model1、model2、model3，我们都进行步骤1、2、3的操作，我们最终得到了训练集的特征向量是3*n（3是第一层的模型1数），得到预测集的特征向量是3*m。</li><li>对于第二层，我们用第一层得到的3*n作为特征用model4进行训练，模型训练结束后对3*m进行预测，得到最终的结果。</li></ol><p>最顶层的模型一般是LR或者线性模型。</p><hr><h4>8.Blending</h4><blockquote><p>Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集，例如说10%的训练数据，第二阶段的stacker模型就基于第一阶段模型对这10%训练数据的预测值进行拟合。说白了，就是把Stacking流程中的K-Fold CV 改成 HoldOut CV。</p></blockquote><p>举例：1.将数据划分成train,test，然后将train划分成不相交的两部分train_1,train_2</p><p>2.使用不同的模型对train_1训练，对train_2和test预测，生成两个1维向量，有多少模型就生成多少维向量</p><p>3.第二层使用前面模型对train_2生成的向量和label作为新的训练集，使用LR或者其他模型训练一个新的模型来预测test生成的向量</p><hr><h4>9.Stacking和Blending的区别</h4><ol><li>stacking由于加入了K-fold，更加复杂；blending不用K-fold，所以更加简单</li><li>stacking因为使用K-fold，所以训练集的数据分布和原数据集的不一样了，会引入估计偏差；而blending不会。</li><li>blending用的数据会过少，多层之后，有可能会过拟合；而stacking不会出现。</li></ol><p>两种方法都可以用下图来表示：<img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-6.png" alt="4.11-6"></p><hr><p>参考相关博客和资料：</p><blockquote><p>1: https://blog.csdn.net/shine19930820/article/details/75209021#11-voting</p><p>2: https://zhuanlan.zhihu.com/p/26890738</p><p>3: https://www.cnblogs.com/liuwu265/p/4690486.html</p><p>4: https://blog.csdn.net/sinat_29819401/article/details/71191219</p><p>5: https://blog.csdn.net/bryan__/article/details/51229032</p><p>6: https://blog.csdn.net/foolsnowman/article/details/51726007</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Ensemble Learning--模型融合&lt;/h3&gt;
&lt;p&gt;含义：
通过对多个单模型融合以提升整体性能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Voting&lt;/p&gt;
&lt;p&gt;2.Averaging&lt;/p&gt;
&lt;p&gt;3.Ranking&lt;/p&gt;
&lt;p&gt;4.Bagging
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Buevara.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="模型融合" scheme="http://Buevara.github.io/tags/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>面经--瓜子二手车数据分析岗位</title>
    <link href="http://Buevara.github.io/2018/04/01/%E9%9D%A2%E7%BB%8F--%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B2%97%E4%BD%8D/"/>
    <id>http://Buevara.github.io/2018/04/01/面经--瓜子二手车数据分析岗位/</id>
    <published>2018-04-01T10:30:41.000Z</published>
    <updated>2018-05-20T05:18:48.303Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--瓜子二手车数据分析岗位</h2><hr><p>面试约的上午九点半，去了直接面试，估计去的太早了。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.介绍一下机器学习模型都有哪些，判别模型和生成模型区别，具体有哪些。</p></li><li><p>3.推导logistic的损失函数。</p></li><li><p>4.什么是过拟合，过拟合如何解决。</p></li><li><p>5.什么是gbdt，gbdt如何确定第一棵树，没答出来，她换了个问法，说给你两个特征x，x1是连续的，x2是非连续的，和对应的label，具体的构建gbdt的方法。</p></li><li><p>6.描述kmeans算法，难度加深，给定一个每个点和其他点的距离而不是坐标，该如何聚类。</p></li><li><p>7.最后一道算法题：不用内置函数求sqrt，给定x和 $\Sigma$, 其中$ \Sigma $是误差项。应该用二分查找，但是最后没写出来。</p></li></ul><p>一面结束，三十分钟左右。</p><hr><h3>二面</h3><ul><li><p>1.自我介绍。</p></li><li><p>2.什么是极大似然估计，如何推导。</p></li><li><p>3.什么是最大后验概率，如何推导。</p></li><li><p>4.描述一下朴素贝叶斯。</p></li><li><p>5.算法题：旋转数组中找到x。leetcode33题</p></li><li><p>6.1求概率：得分问题，赢一局得一分，输一局，不扣分，赢和输概率为p和q，n局得到m分的概率是。</p></li><li><p>6.2前面的问题难度加大，输一局扣一分，求n局得到m分的概率是。</p></li><li><p>6.3难度再提升，扣为0分不降分，n局得到m分的概率是。当时没做出来（应该用动态规划）</p></li><li><p>7.1用一枚硬币（1/2的概率）求出一个1/3的概率。</p></li><li><p>7.2用一枚硬币（1/2的概率）求出一个1/3的概率。</p></li><li><p>7.3用不均匀一枚硬币（概率不为1/2）求出一个1/3的概率。</p></li></ul><p>二面面试官问我有什么要问的，我问了一下他所在的部门是做什么的，都有什么方向，他说在做分类推荐。二面结束，共四十分钟左右，面试官很和善，但是他出的问题都不是我自己独立解答的，80%都需要他的一些指引，认识到了自己的不足，继续努力。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--瓜子二手车数据分析岗位&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;面试约的上午九点半，去了直接面试，估计去的太早了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;一面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.自我介绍.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.介绍一下机器学习模型都有哪些，判别模型
      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--L1正则化项和L2正则化项理解</title>
    <link href="http://Buevara.github.io/2018/04/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--L1%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E5%92%8CL2%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E7%90%86%E8%A7%A3/"/>
    <id>http://Buevara.github.io/2018/04/01/机器学习--L1正则化项和L2正则化项理解/</id>
    <published>2018-04-01T04:17:56.000Z</published>
    <updated>2018-04-11T12:55:39.439Z</updated>
    
    <content type="html"><![CDATA[<h2>L1正则化项和L2正则化项的理解</h2><hr><p>概念：</p><blockquote><p>L1正则化是指权值向量w中各个元素的绝对值之和，通常表示为$ ||W||_{1} $</p></blockquote><blockquote><p>L2正则化是指权值向量w中各个元素的平方和然后再求平方根（可以看到Ridge回归的L2正则化项有平方符号），通常表示为$ ||W||_{2} $</p></blockquote><p>先抛出个结论：</p><blockquote><p>L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于特征选择,L1范数.L2范数是指向量各元素的平方和然后求平方根。我们让L2范数的正则项$ ||W||_{2} $最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，大比起1范数，更常用L2范数。通过L2范数，我们可以实现了对模型空间的限制，从而在一定程度上避免了过拟合；一定程度上，L1也可以防止过拟合</p></blockquote><hr><h3>L1正则化</h3><p>为什么L1正则化可以产生稀疏模型（L1是怎么让系数等于零的），以及为什么L2正则化可以防止过拟合？假设有如下带L1正则化的损失函数：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-18.png" alt="4.9-18"></p><p>其中$ J0 $是原始的损失函数，加号后面的一项是$ L1 $正则化项，$ α $是正则化系数。注意到$ L1 $正则化是权值的绝对值之和，$J$是带有绝对值符号的函数，因此$J$是不完全可微的。机器学习的任务就是要通过一些方法（比如梯度下降）求出损失函数的最小值。当我们在原始损失函数$J0$后添加$L1$正则化项时，相当于对$J0$做了一个约束。令$L=α∑w|w|$，则$J=J0+L$，此时我们的任务变成在$L$约束下求出$J0$取最小值的解。考虑二维的情况，即只有两个权值$w1$和$w2$，此时$L=|w1|+|w2|$对于梯度下降法，求解$J0$的过程可以画出等值线，同时$L1$正则化的函数$L$也可以在$w1w2$的二维平面上画出来。如下图<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-19.png" alt="4.9-19"></p><p>图中等值线是$J0$的等值线，黑色方形是$L$函数的图形。在图中，当$J0$等值线与$L$图形首次相交的地方就是最优解。上图中$J0$与$L$在$L$的一个顶点处相交，这个顶点就是最优解。注意到这个顶点的值是$(w1,w2)=(0,w)$。可以直观想象，因为$L$函数有很多『突出的角』（二维情况下四个，多维情况下更多），$J0$与这些角接触的机率会远大于与$L$其它部位接触的机率，而在这些角上，会有很多权值等于$0$，这就是为什么$L1$正则化可以产生稀疏模型，进而可以用于特征选择。</p><p>而正则化前面的系数$α$，可以控制L图形的大小。$α$越小，$L$的图形越大（上图中的黑色方框）；$α$越大，$L$的图形就越小，可以小到黑色方框只超出原点范围一点点，这是最优点的值$(w1,w2)=(0,w)$中的$w$可以取到很小的值。</p><hr><h3>L2正则化</h3><p>假设有如下带L2正则化的损失函数：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-20.png" alt="4.9-20">同样可以画出他们在二维平面上的图形，如下：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-21.png" alt="4.9-21">二维平面下L2正则化的函数图形是个圆，与方形相比，被磨去了棱角。因此J0与L相交时使得w1或w2等于零的机率小了许多，这就是为什么L2正则化不具有稀疏性的原因。</p><hr><h3>L2正则化和过拟合</h3><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。</p><blockquote><p>那为什么L2正则化可以获得值很小的参数？</p></blockquote><p>以线性回归中的梯度下降法为例。假设要求的参数为$θ$，$hθ(x)$是我们的假设函数，那么线性回归的代价函数如下：以线性回归中的梯度下降法为例。假设要求的参数为$θ，hθ(x)$是我们的假设函数，那么线性回归的代价函数如下：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-22.png" alt="4.9-22">那么在梯度下降法中，最终用于迭代计算参数θ的迭代式为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-23.png" alt="4.9-23"><img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-24.png" alt="4.9-24">其中$α$是learning rate. 上式是没有添加L2正则化项的迭代公式，如果在原始代价函数之后添加L2正则化，则迭代公式会变成下面的样子：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-25.png" alt="4.9-25">其中$λ$就是正则化参数。从上式可以看到，与未添加$L2$正则化的迭代公式相比，每一次迭代，$θj$都要先乘以一个小于1的因子，从而使得$θj$不断减小，因此总得来看，$θ$是不断减小的。最开始也提到$L1$正则化一定程度上也可以防止过拟合。之前做了解释，当$L1$的正则化系数很小时，得到的最优解会很小，可以达到和$L2$正则化类似的效果。</p><hr><h3>正则化参数的选择</h3><blockquote><p>通常越大的$λ$可以让代价函数在参数为$0$时取到最小值。</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-26.png" alt="4.9-26"></p><p>分别取$λ=0.5$和$λ=2$，可以看到越大的$λ$越容易使$F(x)$在$x=0$时取到最小值。</p><blockquote><p>$λ$越大，$θj$衰减得越快。另一个理解可以参考上图，$λ$越大，$L2$圆的半径越小，最后求得代价函数最值时各参数也会变得很小。</p></blockquote><h2>除了：L1和L2 regularization外，正则化常用的方法还有：数据集扩增、dropout</h2><p>文章转自 <a href="https://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="noopener">阿拉丁吃米粉的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;L1正则化项和L2正则化项的理解&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;L1正则化是指权值向量w中各个元素的绝对值之和，通常表示为$ ||W||_{1} $&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;L2正则化
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://Buevara.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="正则化" scheme="http://Buevara.github.io/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>面经--小米机器学习岗位</title>
    <link href="http://Buevara.github.io/2018/03/31/%E9%9D%A2%E7%BB%8F--%E5%B0%8F%E7%B1%B3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B2%97%E4%BD%8D/"/>
    <id>http://Buevara.github.io/2018/03/31/面经--小米机器学习岗位/</id>
    <published>2018-03-31T11:40:13.000Z</published>
    <updated>2018-05-20T05:19:02.819Z</updated>
    
    <content type="html"><![CDATA[<h2>面经--小米机器学习算法岗位</h2><hr><p>感谢两位校友@<a href="https://marcovaldong.github.io/" target="_blank" rel="noopener">Marcovaldo</a>和@<a href="http://coconlp.top/" target="_blank" rel="noopener">KillersDeath</a>提供的面经。面试约的下午三点，第一次面试，心里有点紧张。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.介绍一下机器学习模型都有哪些。</p></li><li><p>3.深度学习网络的网络特性和不同，主要说了Alexnet和ResNet的主要特征。说的时候问到是不是用layers直接写，我说最早也用conv和pooling，relu写过浅层的网络。</p></li><li><p>4.梯度爆炸和梯度消失，梯度爆炸当时没理解清，没回答的很明白。这个解释很好：<a href="https://www.zhihu.com/question/66027838/" target="_blank" rel="noopener">梯度爆炸</a></p></li><li><p>5.项目上对如何找特征，用了什么模型和技巧，损失函数用的什么。我说用的gbdt，xgboost和SVM，他问我gbdt和SVM哪个对特征不需要处理（gbdt）， xgboost和gbdt的区别，回答速度快。问为什么xgboost速度快，回答用了二阶导数，问xgboost可以自定义损失函数，那你比赛利用的损失函数是什么，你对你的损失函数求一下二阶导，这坑挖的，算了半天没算出来。</p></li><li><p>6.L1、L2正则化的区别，为什么会产生稀疏性，为什么会降低特征权重。</p></li><li><p>7.给1张5*5*3的图片，3*3*64的卷积，用到了多少参数。（应该是想问我卷积层参数共享）</p></li><li><p>8.最后一道算法题：排序数组中给定某个重复出现数字第一次出现的下标。 剑指offer原题，算了半天用了两次二分查找，才写出来，面试官估计不咋满意。</p></li></ul><p>一面结束，四十分钟左右。</p><hr><h3>二面</h3><p>面试官应该是C++大神，想问我指针和数据流方面的题，但我都不会。于是问了三道算法题和一些小问题：</p><ul><li><p>1.一个n*m的矩阵，所有数无顺序，求第k大的数。想用快排，面试官说可以，但是不是最好的。最后没想出来，结束后和同学讨论应该是堆排序加上mapreduce。</p></li><li><p>2.反转链表。剑指offer原题。</p></li><li><p>3.中间问了一下函数的传参问题。</p></li><li><p>4.问了堆排序。</p></li><li><p>5.旋转数组找k。leetcode33题。</p></li></ul><p>二面结束，三十分钟左右，写算法特别慢，估计挂了。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;面经--小米机器学习算法岗位&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;感谢两位校友@&lt;a href=&quot;https://marcovaldong.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Marcovaldo&lt;/a&gt;和@&lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="面经" scheme="http://Buevara.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--回文串问题</title>
    <link href="http://Buevara.github.io/2018/03/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://Buevara.github.io/2018/03/25/算法基础--回文串问题/</id>
    <published>2018-03-25T00:40:35.000Z</published>
    <updated>2018-04-16T15:08:57.366Z</updated>
    
    <content type="html"><![CDATA[<h3>什么是回文palindrome？</h3><blockquote><p>回文指的是正读和反读都一样的字符串，如aba，abba等</p></blockquote><hr><h3>字符子串和字符子序列的区别?</h3><blockquote><p>字符字串指的是字符串中连续的n个字符；如palindrome中，pa，alind，drome等都属于它的字串而字符子序列指的是字符串中不一定连续但先后顺序一致的n个字符；如palindrome中，plind，lime属于它的子序列，而mod，rope则不是，因为它们与字符串的字符顺序不一致。</p></blockquote><hr><h3>最长回文子序列</h3><blockquote><p>题目要求：给定字符串，求它的最长回文子序列长度。回文子序列反转字符顺序后仍然与原序列相同。例如字符串abcdfcba中，最长回文子序列长度为7，abcdcba或abcfcba。</p></blockquote><p>解题思路：动态规划头尾字符串分别为start和end</p><p>如果首尾字符串相同，即s[start] = s[end] 那么最长回文子序列就等于dp[start+1][end-1] + 2</p><p>如果首尾字符串不同，那么最长回文子序列就在dp[start+1][end]和dp[start][end-1]之间</p><p>状态初始条件：$$dp[start][end]=1 ， start=end$$状态转移方程：$$ dp[start][end]=dp[start+1][end-1] + 2 , if（str[start]==str[end]） $$$$ dp[start][end]=max(dp[start+1][end], dp[start][end-1]) , if（str[start]！=str[end]） $$</p><p>注意：</p><ol><li>当start == end时，dp[start][end]=1,即它本身</li><li>end 应该大于等于start</li><li>最重要的是要考虑start和end循环的方向，由于dp[start][end]和dp[start+1][end]、dp[start][end-1]、dp[start+1][end-1]有关系，我们可以得出结论是start是从大到小进行循环，end是从小到大进行循环</li></ol><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[start][start] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(start+<span class="number">1</span>, n, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[start] == s[end]:</span><br><span class="line">                dp[start][end] = dp[start+<span class="number">1</span>][end<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                dp[start][end] = max(dp[start+<span class="number">1</span>][end], dp[start][end<span class="number">-1</span>])</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line">print(sol(<span class="string">'abcdfcba'</span>))</span><br></pre></td></tr></table></figure></p><hr><h3>回文子序列个数</h3><blockquote><p>题目要求：给定字符串，求它的回文子序列个数。回文子序列反转字符顺序后仍然与原序列相同。例如字符串aba中，回文子序列为&quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;b&quot;, &quot;aba&quot;，共5个。内容相同位置不同的子序列算不同的子序列。</p></blockquote><p>解题思路：动态规划对于任意字符串，如果头尾字符不相等，则字符串的回文子序列个数就等于去掉头的字符串的回文子序列个数+去掉尾的字符串的回文子序列个数-去掉头尾的字符串的回文子序列个数；</p><p>如果头尾字符相等，那么除了上述的子序列个数之外，还要加上首尾相等时新增的子序列个数，<strong>1+去掉头尾的字符串的回文子序列个数</strong>，1指的是加上头尾组成的回文子序列，如aa，bb等。</p><p>状态初始条件：$$dp[start][end]=1 ， start=end$$状态转移方程：$$ dp[start][end]=dp[start+1][end] + dp[start][end-1]-dp[start+1][end-1]+dp[start+1][end-1] + 1==dp[start+1][end] + dp[start][end-1] + 1, if（str[start]==str[end]） $$$$ dp[start][end]=dp[start+1][end] + dp[start][end-1]-dp[start+1][end-1] , if（str[start]！=str[end]） $$</p><ol><li>当start == end时，dp[start][end]=1,即它本身</li><li>end 应该大于等于start</li><li>start依然是从大到小进行循环，end依然是从小到大进行循环</li></ol><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[start][start] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(start+<span class="number">1</span>, n, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[start] == s[end]:</span><br><span class="line">                dp[start][end] = dp[start+<span class="number">1</span>][end]+ dp[start][end<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                dp[start][end] = dp[start+<span class="number">1</span>][end]+ dp[start][end<span class="number">-1</span>] -dp[start+<span class="number">1</span>][end<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line">print(sol(<span class="string">'xxy'</span>))</span><br></pre></td></tr></table></figure></p><hr><h3>最大回文子串的长度 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">leetcode</a></h3><blockquote><p>题目要求：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 长度最长为1000。示例：</p><blockquote><p>输入: &quot;babad&quot;输出：&quot;bab&quot;注意: &quot;aba&quot;也是有效答案</p></blockquote></blockquote><p>解题思路：</p><p>1.最快的方法：O(N)  --- 经典的'马拉车算法'</p><p><a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">详细请点击</a></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    ss = <span class="string">'$#'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        ss += i</span><br><span class="line">        ss += <span class="string">'#'</span></span><br><span class="line">    <span class="keyword">return</span> ss</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Manacher</span><span class="params">(s)</span>:</span></span><br><span class="line">    ss = sol(s)</span><br><span class="line">    n = len(ss)</span><br><span class="line">    p = [<span class="number">0</span>]*n</span><br><span class="line">    idd = <span class="number">0</span></span><br><span class="line">    mx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i &lt; mx:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span>*idd - i &gt;<span class="number">-1</span>:</span><br><span class="line">                </span><br><span class="line">                p[i] = min(p[<span class="number">2</span>*idd-i], mx-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p[i] = mx-i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i+p[i]&lt;n <span class="keyword">and</span> i-p[i]&gt;=<span class="number">0</span>) <span class="keyword">and</span>  ss[i+p[i]] == ss[i-p[i]]:</span><br><span class="line">            p[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p[i] + i &gt; mx:</span><br><span class="line">            mx = p[i]+i</span><br><span class="line">            idd = i</span><br><span class="line">    <span class="keyword">return</span> max(p)<span class="number">-1</span></span><br><span class="line">   </span><br><span class="line">print(Manacher(<span class="string">'zedyxabaxy'</span>))</span><br></pre></td></tr></table></figure></p><p>解题思路：</p><p>2.动态规划：O(N^2)</p><p>start &gt;= end</p><p>状态初始条件：$$dp[start][end]=True ， start=end$$状态转移方程：$$ dp[start][end]= str[start] == str[end] end-strart=1 $$</p><p>$$ dp[start][end]= str[start]==str[end]* And * dp[start+1][end-1]  end - start&gt;1  $$</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [[<span class="keyword">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[i][i] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> j-i == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> &lt;= j<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> (dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="comment">#print(dp)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j-i+<span class="number">1</span> &gt;maxx:</span><br><span class="line">                maxx = j-i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxx            </span><br><span class="line">print(sol(<span class="string">'xdadadxy'</span>))</span><br></pre></td></tr></table></figure></p><hr><h3>回文链表 <a href="https://blog.csdn.net/liujunyang0926/article/details/53207216" target="_blank" rel="noopener">原链接</a></h3><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-1.png" alt="4.10-1"></p><p>解题思路：</p><p>仔细观察一个回文比如：1 2 3 4 5 5 4 3 2 1发现有什么规律？假象把这个链表对折，那么相应的每个对称的数字都对的上（这不废话~），其实这个对折过程就是先把链表的一半（前一半后一半都行）反转然后在匹配的过程，如果是回文当然能一一对应上啦</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-2.png" alt="4.10-2"></p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-3.png" alt="4.10-3"></p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-4.png" alt="4.10-4"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;什么是回文palindrome？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;回文指的是正读和反读都一样的字符串，如aba，abba等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3&gt;字符子串和字符子序列的区别?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;字符字串指的
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://Buevara.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回文串" scheme="http://Buevara.github.io/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--数学问题</title>
    <link href="http://Buevara.github.io/2018/03/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://Buevara.github.io/2018/03/25/算法基础--数学问题/</id>
    <published>2018-03-25T00:40:35.000Z</published>
    <updated>2018-04-12T14:25:37.861Z</updated>
    
    <content type="html"><![CDATA[<h3>记录一下算法中出现的数学问题。</h3><blockquote><p>1.计算最小公倍数2.计算平方根3.不用加减乘除运算符做加法</p></blockquote><hr><h3>1.计算最小公倍数</h3><blockquote><p>题目要求：给定一个数n，求n之前（包括n）所有正整数的值得最小公倍数。</p></blockquote><p>解题思路：判断小于n的数里有多少个质数，质数由z1，z2，z3...zm组成，求得对于每一个质数z的$ int(log_{z}^{n}) $，</p><p>例如： 5小于等于5的质数由[2,3,5]答案是：2<sup>{int(log_{2}</sup>{5})}* 3<sup>{int(log_{3}</sup>{5})}* 5<sup>{int(log_{3}</sup>{5})} = 60</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    prime = [<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        sign = <span class="keyword">True</span></span><br><span class="line">        m = int(math.sqrt(i))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                sign = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sign:</span><br><span class="line">            prime.append(i)</span><br><span class="line">    <span class="keyword">return</span> prime</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logK</span><span class="params">(k, n)</span>:</span></span><br><span class="line">    res = k</span><br><span class="line">    <span class="keyword">while</span> res &lt; n:</span><br><span class="line">        res *= k</span><br><span class="line">    <span class="keyword">if</span> res&gt; n:</span><br><span class="line">        <span class="keyword">return</span> int(res/k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tosum</span><span class="params">(l, n)</span>:</span></span><br><span class="line">    summ = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        summ *= logK(i, n)</span><br><span class="line">    <span class="keyword">return</span> summ</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(n)</span>:</span></span><br><span class="line">    l = isPrime(n)</span><br><span class="line">    <span class="keyword">return</span> tosum(l, n)</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="number">10</span>))  <span class="comment">##例子</span></span><br></pre></td></tr></table></figure></p><hr><h3>2.求平方根</h3><blockquote><p>题目要求：给定一个数n和误差参数 $ \varepsilon  $，求数n的平方根，并且误差不能大于 $ \varepsilon  $。</p></blockquote><p>解题思路：二分查找的经典题。每次start和end的中点mid的平方+e和目标值n做比较。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span><span class="params">(s, start, end, e)</span>:</span></span><br><span class="line">    mid = (start+end)/<span class="number">2.0</span></span><br><span class="line">    <span class="keyword">if</span> mid**<span class="number">2</span>+e &gt;=s <span class="keyword">and</span> s&gt;=mid**<span class="number">2</span>-e:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> mid**<span class="number">2</span>+e &gt;s:</span><br><span class="line">            <span class="keyword">return</span> binary(s, start, mid,e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary(s, mid, end, e)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tosqrt</span><span class="params">(n, e)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = n</span><br><span class="line">    <span class="keyword">return</span> binary(n, start, end, e)</span><br><span class="line">    </span><br><span class="line">print(tosqrt(<span class="number">10</span>, <span class="number">0.5</span>)) <span class="comment">##测试</span></span><br></pre></td></tr></table></figure></p><hr><h3>3. 不用加减乘除运算符做加法(<a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">剑指offer</a>)</h3><blockquote><p>设计一个算法，不使用加减乘数运算符号实现加法运算。</p></blockquote><p>解题思路：</p><p>位运算：</p><p>第一步：计算两个数的对应位，但是不计算进步，主要有四种情况，0+0=0，0+1=1，1+0=1，1+1=0，可以看出这正好对应异或操作。</p><p>第二步：计算两个数的进位，只有在1+1的情况下才会有进位，这正好对应与运算，计算完之后，每位上的数正好是后一位的进位，这时把结果左移一位即可。</p><p>第三步：把第一步的结果和第二步的结果相加，查看是否有进位，如果有进位重复第一步和第二步，直到没有进位为止。注意：python如果数值大于32位，自动转化为long，我们不能让数值转换为long，做了一些限制。更为详细请点击：<a href="https://www.v2ex.com/t/195894" target="_blank" rel="noopener">参考python的int整型转化long</a><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-1.png" alt="4.11-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line"><span class="comment">## python int最大值</span></span><br><span class="line">        MAX = <span class="number">0x7FFFFFFF</span></span><br><span class="line"><span class="comment">## python int最小值</span></span><br><span class="line">        MIN = <span class="number">0x80000000</span></span><br><span class="line"><span class="comment">## 防止转化成long的标志数</span></span><br><span class="line">        mask = <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; mask <span class="comment">##转换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= MAX <span class="keyword">else</span> ~(a ^ mask) <span class="comment">##防止越界</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;记录一下算法中出现的数学问题。&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.计算最小公倍数
2.计算平方根
3.不用加减乘除运算符做加法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3&gt;1.计算最小公倍数&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;题目要求：
给定
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://Buevara.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--各种排序算法的性质</title>
    <link href="http://Buevara.github.io/2018/01/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
    <id>http://Buevara.github.io/2018/01/31/算法基础--各种排序算法的性质/</id>
    <published>2018-01-31T02:12:56.000Z</published>
    <updated>2018-04-11T12:18:21.663Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>算法种类</th><th>最好情况</th><th>平均情况</th><th>最坏情况</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>是</td></tr><tr><td>冒泡排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>是</td></tr><tr><td>简单选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>否</td></tr><tr><td>希尔排序</td><td></td><td></td><td></td><td>O(1)</td><td>否</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>否</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>否</td></tr><tr><td>2-路归并</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>是</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(r)</td><td>是</td></tr></tbody></table><h2>快速排序</h2><p>快速排序是每趟都确定一个元素的位置，并且在它的位置左边的都比它小，在它右边的都比它大。</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void QuickSort(ElemType A[], int low, int high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        int pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition(ElemType A[], int low, int high)&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high] &gt; pivot) high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low] &lt; pivot) low++;</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>堆排序</h2><p>堆排序是先要构建成大顶堆，而后依次将root跟二叉树最后一个元素互换，每次互换后都要将二叉树再调整回大顶堆。</p><p>下面是建立大顶堆的过程：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; A[<span class="number">0</span>])</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是堆排序算法：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);</span><br><span class="line">    <span class="keyword">for</span>(i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        Swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        AdjustDown(A, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>堆支持删除和插入操作。删除堆顶元素时先将堆顶元素与最后一个元素互换，之后进行向下调整。插入元素时，直接将元素插入到最后的位置，之后进行向上调整。下面是执行向上调整的函数：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(ElemType A[], <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//参数k为向上调整的结点，也就是堆中的元素个数</span></span><br><span class="line">    A[<span class="number">0</span>] = A[k];</span><br><span class="line">    <span class="keyword">int</span> i = k / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;A[<span class="number">0</span>])&#123;</span><br><span class="line">        A[k] = A[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>简单选择排序</h2><p>假设排序表为L[1...n]，第i趟排序即从L[1...n]中选择关键字最小的元素与L[i]进行交换，每一趟排序都可以确定一个元素的最终位置，经过n-1趟排序就可以使整个排序表有序。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">            Swap(A[i], A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法种类&lt;/th&gt;
&lt;th&gt;最好情况&lt;/th&gt;
&lt;th&gt;平均情况&lt;/th&gt;
&lt;th&gt;最坏情况&lt;/th&gt;
&lt;th&gt;空间复杂度&lt;/th&gt;
&lt;th&gt;是否稳定&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Buevara.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://Buevara.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
