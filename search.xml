<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spark基础(一)--大数据技术介绍</title>
      <link href="/2019/07/15/Spark%E5%9F%BA%E7%A1%80(%E4%B8%80)--%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/07/15/Spark%E5%9F%BA%E7%A1%80(%E4%B8%80)--%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本篇博客是学习<a href="http://dblab.xmu.edu.cn/blog/spark/" target="_blank" rel="noopener">子雨大数据之Spark入门教程</a>的学习笔记，仅作学习之用。</p><h2>1.代表性的大数据技术</h2><ul><li>Hadoop</li><li>Spark</li><li>Flink</li><li>Beam</li></ul><p>主要计算模式如图1-1<img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-1.png" alt="图1-1 大数据主要计算模式"></p><h3>1.1 Hadoop</h3><p>Hadoop的生态系统图如图1-2<img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-2.png" alt="图1-2 hadoop生态系统"></p><p>开源谷歌GFS，利用MapReduce分布式并行编程，<strong>MapReduce</strong>和<strong>HDFS</strong>是Hadoop的两大核心。</p><ul><li><p>HDFS 分布式文件管理系统</p></li><li><p>Hive 数据仓库</p></li></ul><blockquote><p>数据仓库，借助底层HDFS和HBase完成存储，接受用户的SQL语句，转换为MapReduce程序进行查询，避免了大量的费时处理，类似于一个接口</p></blockquote><ul><li>Pig 数据流处理</li></ul><blockquote><p>数据流转换，存入数据仓库中</p></blockquote><ul><li>Mahout 数据挖掘库</li></ul><blockquote><p>支持MapReduce，写好了算法库，专门用来解决机器学习的算法，现在已经转向Spark平台</p></blockquote><ul><li>Flume 日志收集</li></ul><blockquote><p>日志实时采集。</p></blockquote><ul><li>Sqoop 数据ETL</li></ul><blockquote><p>关系型数据库批量导出并存入非关系型数据库（HBase、HDFS）。也可以将非关系型数据库数据转换为关系型数据库数据。</p></blockquote><ul><li>HBase 分布式数据库</li></ul><blockquote><p>非关系型数据库，列族数据库。</p></blockquote><ul><li>Zookeeper 分布式协作服务</li></ul><blockquote><p>选择在服务器中选择主管家，备用管家的任务。</p></blockquote><ul><li>Ambari 安装、部署、配置和管理工具</li></ul><blockquote><p>可视化监视和自动化部署。</p></blockquote><ul><li><strong>MapReduce 分布式计算框架</strong></li></ul><blockquote><p>MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数：Map和Reduce编程容易，不需要掌握分布式并行编程细节，也可以很容易把自己的程序运行在分布式系统上，完成海量数据的计算•MapReduce采用“分而治之”策略，一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的分片（split），这些分片可以被多个Map任务并行处理图1-3 为MapReduce的工作流程。第一步先进行分片，有多少个分片就有多少个Map。计算后给到Reduce合并，Reduce必须等所有Map结束才可运行。</p></blockquote><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-3.png" alt="图1-3 MapReduce工作流程"></p><blockquote><p>什么是数据向计算靠拢，什么是计算向数据靠拢？</p><blockquote><p>举例：NLP任务，把许多词块放到不同的机器上，为了做计算，讲不同的词块拉倒同一台机器上进行处理，叫做数据向计算靠拢。代价非常大。非常大的文件放在不同机器上，如果这台机器A速度快，把MapReduce分发代码程序到这台机器A上，靠近数据所在地方运行程序，把结果传给管家节点，进行汇总。这叫计算向数据靠拢。</p></blockquote></blockquote><blockquote><p>MapReduce采用计算向数据靠拢，如图1-4所示。</p></blockquote><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-4.png" alt="图1-4  计算向数据靠拢示意图"></p><blockquote><p>Hadoop不需要了解底层技术，所有和分布式并行编程细节，编程简单，和开发单机版本无太大区别。</p></blockquote><ul><li><strong>YARN 资源调度和管理框架</strong></li></ul><blockquote><p>为MapReduce提供资源，进行调度，类似于“管家”</p></blockquote><blockquote><p>YARN 为什们那么重要？</p><blockquote><p>如图1-5。原来的方法造成不同集群利用不平衡。<img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-5.png" alt="图1-5 YARN的重要性"></p></blockquote></blockquote><blockquote><blockquote><p>所以引入YARN，如图1-6。优点如图1-7。</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-6.png" alt="图1-6 YARN工作原理"></p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-7.png" alt="图1-7 YARN的优势"></p><h3>1.2 Spark</h3><p>Spark慢慢代替Hadoop中的MapReduce。Spark架构图如图1-8所示。</p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-8.png" alt="图1-8 Spark架构图"></p><ul><li>Spark Core</li></ul><blockquote><p>我们通常所学习的。</p></blockquote><ul><li>Spark SQL</li></ul><blockquote><p>对关系型数据库进行存取。</p></blockquote><ul><li>Spark Streaming</li></ul><blockquote><p>进行流计算。</p></blockquote><ul><li>MLib</li></ul><blockquote><p>做机器学习算法。</p></blockquote><ul><li>GraphX</li></ul><blockquote><p>做图算法。</p></blockquote><p>Spark生态系统如图1-9所示。</p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-9.png" alt="图1-9 Spark生态系统"></p><p>相比于Hadoop优势：全方位软件栈，只要学习掌握Spark自身一门语言，就可以编写不同应用环境下的应用程序。Spark可以和Hadoop进行兼容，例如Spark可以对HDFS进行存取，也可以HIVE+Spark，HBase+Spark，NoSQL+Spark。</p><p>图1-10、图1-11、图1-12和图1-13是Spark和Hadoop进行对比：<img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-10.png" alt="图1-10 Spark和Hadoop进行对比"></p><p>1.机器学习算法是一个不断迭代的过程，对于磁盘的IO性能消耗非常大。没法在MapReduce实现。2.耗时过长，Reduce需要在所有Map都结束后才能运行。</p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-11.png" alt="图1-11 Spark和Hadoop进行对比"></p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-12.png" alt="图1-12 Spark和Hadoop进行对比"></p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-13.png" alt="图1-13 Spark和Hadoop进行对比"></p><h3>1.3 Flink</h3><p>Flink架构图如图1-14所示。<img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-14.png" alt="图1-14 Flink架构图"></p><p>Flink和Spark的对比如图1-15、图1-16、图1-17所示。<img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-15.png" alt="图1-15 Flink和Spark的比较"></p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-16.png" alt="图1-16 Flink和Spark的比较"></p><p><img src="https://raw.githubusercontent.com/Buevara/blog_img/master/Spark_Study/1.BigData%20Introduction/1-17.png" alt="图1-17 Flink和Spark的比较"></p><p>Flink略晚于Spark面世，所以用的并没有Spark广泛。</p><h3>1.4 Beam</h3><p>谷歌开发的集大成的大数据平台。谷歌正在大力推广。</p>]]></content>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--股票买卖问题</title>
      <link href="/2018/09/24/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/24/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2>股票买卖问题总结：</h2><hr><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">股票买卖问题总结：</span><br><span class="line">1. 只能买卖一次</span><br><span class="line">2. 买卖无限次</span><br><span class="line">3. 买卖无限次但是每次需要手续费a元</span><br><span class="line">4. 买卖无限次，但每次卖出后需要“冷静”一天</span><br><span class="line">5. 只能买卖两次</span><br><span class="line">6. 买卖小于等于两次</span><br><span class="line">7. 买卖小于等于k次</span><br><span class="line"></span><br><span class="line">参考文献：</span><br><span class="line">https://segmentfault.com/a/1190000006672807#articleHeader3</span><br><span class="line">https://blog.csdn.net/sinat_35261315/article/details/79023510</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">################################## 1.只买卖一次 #########################################</span><br><span class="line">##输入: [7,1,5,3,6,4]</span><br><span class="line">##输出: 5</span><br><span class="line">###第一种 添加两个数组 一个是从第i位起，后面的最大值（包括第i位）， 另一个是第i位以及之前，最小值</span><br><span class="line">def solve1_1(nums):</span><br><span class="line">    if len(nums) == 0 or len(nums) == 1:</span><br><span class="line">        return 0</span><br><span class="line">    n1 = [0]*len(nums)</span><br><span class="line">    n2 = [0]*len(nums)</span><br><span class="line">    n2[0] = nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        n2[i] = min(nums[i-1], nums[i])</span><br><span class="line"></span><br><span class="line">    n1[len(nums)-1] = nums[len(nums)-1]</span><br><span class="line">    for i in range(len(nums)-2, -1, -1):</span><br><span class="line">        n1[i] = max(nums[i], n1[i+1])</span><br><span class="line">    result = map(lambda x,y:x-y,  n1, n2)</span><br><span class="line">    return max(result)</span><br><span class="line">#print(solve1_1([7,1,5,3,6,4]))</span><br><span class="line"></span><br><span class="line">###第二种方法 思想一样 但是不创建两个数组</span><br><span class="line"></span><br><span class="line">def solve1_2(nums):</span><br><span class="line">    if len(nums) == 0 or len(nums) == 1:</span><br><span class="line">        return 0</span><br><span class="line">    minn = nums[0]###初始化minn最小值</span><br><span class="line">    max_diff = 0 ###初始化最大收益值</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        if nums[i-1] &lt; minn:</span><br><span class="line">            minn = nums[i-1]</span><br><span class="line">        if max_diff&lt; nums[i] - minn:</span><br><span class="line">            max_diff = nums[i] - minn</span><br><span class="line">    return max_diff</span><br><span class="line">#print(solve1_2([7,1,5,3,6,4]))</span><br><span class="line"></span><br><span class="line">################################## 2.可以买卖无限次 #########################################</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">要求和上面一样，不过这次可以进行多次交易，即买，卖，买，卖，买，卖…，其中买卖不能在同一天进行</span><br><span class="line"></span><br><span class="line">这样就不能像上面那样只求一次了，其实仔细想一下，序列无非三种排列</span><br><span class="line"></span><br><span class="line">递增，假设A&lt;B&lt;C&lt;D</span><br><span class="line">递减，假设A&gt;B&gt;C&gt;D</span><br><span class="line">无序，假设A&lt;B&gt;C&lt;D</span><br><span class="line">对于递增序列，最大的差值就是D−A，因为(D−A)=(D−C)+(C−B)+(B−A)&gt;(D−C)+(B−A)</span><br><span class="line">对于递减序列，为0</span><br><span class="line"></span><br><span class="line">对于无序序列，总可以找到若干个递增序列，就上面的例子而言最大差值为(B−A)+(D−C)，而实际上也可以写成(D−C)+max(C−B,0)+(B−A)，和递增序列的形式是一样的</span><br><span class="line"></span><br><span class="line">所以只要依次计算prices[i]−prices[i−1]即可</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve2_1(nums):</span><br><span class="line">    result = 0</span><br><span class="line"></span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line"></span><br><span class="line">        if nums[i]&gt;nums[i-1]:</span><br><span class="line">            result += nums[i]-nums[i-1]</span><br><span class="line">    return result</span><br><span class="line">#print(solve2_1([1, 2, 1, 3, 0, 4]))</span><br><span class="line"></span><br><span class="line">################################## 3.买卖无限次但是需要手续费 ################################</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出: 8   解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1   在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4   在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">第一解法：贪心算法  不是很好理解  个人不推荐</span><br><span class="line">选择的关键是找到一个最大后是不是能够卖掉stock，重新开始寻找买入机会。比如序列1 3 2 8，如果发现2小于3就完成交易买1卖3，此时由于fee=2，（3-1-fee）+(8-2-fee)&lt;8-1-fee)，所以说明卖早了，令max是当前最大price，当（maxx-price[i]&gt;=fee）时可以在max处卖出，且不会存在卖早的情况，再从i开始重新寻找买入机会。</span><br><span class="line">cur_diff记录了当前一次交易能得到的最大收益，只有当maxx-prices[i]&gt;=fee时，才将cur_diff累加到总的收益中。最后一次交易不需要考虑是否早卖了，所以直接累加最后一次的cur_diff。</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def solve3_1(nums, fee):</span><br><span class="line">    ##每次收取fee元手续费</span><br><span class="line">    minn = nums[0]</span><br><span class="line">    maxx = nums[0]</span><br><span class="line">    result = 0</span><br><span class="line">    cur_diff = 0</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        minn = min(minn, nums[i])</span><br><span class="line">        maxx = max(maxx, nums[i])</span><br><span class="line">        print(&apos;min, max&apos;, minn, maxx)</span><br><span class="line">        cur_diff = max(cur_diff, nums[i]-minn-fee)</span><br><span class="line">        print(&apos;cur_diff&apos;, cur_diff)</span><br><span class="line">        if maxx - nums[i] &gt;= fee:</span><br><span class="line">            result += cur_diff</span><br><span class="line">            cur_diff = 0</span><br><span class="line">            minn = nums[i]</span><br><span class="line">            maxx = nums[i]</span><br><span class="line">        print(&apos;result&apos;, result)</span><br><span class="line">    return result+cur_diff</span><br><span class="line"></span><br><span class="line">#print(solve3_1([1, 3, 2, 8, 4, 9], 2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">第二种解法： 动态规划 </span><br><span class="line">分析每天的行为，我们可以知道，主要的行为就是售出和购入。所以我们建立两个动态规划数组：sold和hold，其中</span><br><span class="line">sold[i]保存的是第i天出售股票后的最大利润，有两个状态，一个是在i天售出的利润，</span><br><span class="line">或者保持前一天也就是sold[i-1]的售出利润，选择其中的最大利润。</span><br><span class="line">hold[i]保存的是第i天持有股票的最大利润，也有两个状态，一个是在i天购入的利润，</span><br><span class="line">或者保持前一天也就是hold[i-1]的持有利润，选择其中的最大利润。</span><br><span class="line">写为动态规划式为： </span><br><span class="line">sold[i] = max(sold[i−1],hold[i−1]+prices[i]−fee); </span><br><span class="line">hold[i] = max(Hold[i-1],sold[i−1]−prices[i])</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/Koala_Tree/article/details/78530510</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve3_2(nums, fee):</span><br><span class="line">    sold = [0]*len(nums)</span><br><span class="line">    hold = [0]*len(nums)</span><br><span class="line">    hold[0] = -nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        sold[i] = max(sold[i-1], hold[i-1] + nums[i]-fee)</span><br><span class="line">        hold[i] = max(hold[i-1], sold[i-1] - nums[i])</span><br><span class="line">    return sold[len(nums)-1]</span><br><span class="line">#print(solve3_2([1, 3, 2, 8, 4, 9], 2))</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">第三种解法： 简化第二种解法空间复杂度 O(1)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve3_3(nums, fee):</span><br><span class="line">    sold = 0</span><br><span class="line">    hold = -nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        sold_old = sold</span><br><span class="line">        sold = max(sold, hold + nums[i]-fee)</span><br><span class="line">        hold = max(hold, sold_old - nums[i])</span><br><span class="line">    return sold</span><br><span class="line">#print(solve3_3([1, 3, 2, 8, 4, 9], 2))</span><br><span class="line"></span><br><span class="line">############################## 4.买卖无限次，但每次卖出后需要“冷静”1天 #######################</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">prices = [1, 2, 3, 0, 2]</span><br><span class="line">maxProfit = 3</span><br><span class="line">transactions = [buy, sell, cooldown, buy, sell]</span><br><span class="line"></span><br><span class="line">根据3_2的思想 动态规划 sold和hold</span><br><span class="line">思路： </span><br><span class="line">sold[i] = max(hold[i-1] + price[i], sold[i-1])</span><br><span class="line">hold[i]  = max(sold[i-2] - price[i], hold[i-1]) </span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/grandyang/p/4997417.html</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve4_1(nums):</span><br><span class="line"></span><br><span class="line">    if len(nums) == 0 or len(nums) == 1:</span><br><span class="line">        return 0</span><br><span class="line">    sold = [0] * len(nums)</span><br><span class="line">    hold = [0] * len(nums)</span><br><span class="line">    hold[0] = -nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        sold[i] = max(hold[i - 1] + nums[i], sold[i - 1])</span><br><span class="line">        hold[i] = max(sold[i - 2] - nums[i], hold[i - 1])</span><br><span class="line">    return sold[len(nums) - 1]</span><br><span class="line">#print(solve4_1([2, 1, 3, 0, 0, 3, 2]))</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">第二种方法  简化 solve4_1 </span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def solve4_2(nums):</span><br><span class="line"></span><br><span class="line">    if len(nums) == 0 or len(nums) == 1:</span><br><span class="line">        return 0</span><br><span class="line">    sold = 0</span><br><span class="line">    pre_sold = 0</span><br><span class="line">    hold = -nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        tmp = sold</span><br><span class="line">        sold = max(hold + nums[i], sold)</span><br><span class="line">        hold = max(pre_sold - nums[i], hold)</span><br><span class="line">        pre_sold = tmp</span><br><span class="line">    return sold</span><br><span class="line">#print(solve4_2([2, 1, 3, 0, 0, 3, 2]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################## 5.只能买卖两次 #########################################</span><br><span class="line"></span><br><span class="line">##1, 2, 1, 3, 0, 4；最大收益为6，在第三天买入，第四天卖出，第五天买入，第六天卖出；</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">第一种方式:</span><br><span class="line">两次股票交易的核心是可以定义一个交易点，在这个交易点之前可以做一次交易(赚的最大数目的钱为firstProf)，</span><br><span class="line">在这个交易点之后可以做一个交易(赚的最大数目的钱是secondProf)。</span><br><span class="line">那么要求的是max(firstProf+secondProf)。但是这个方法的时间复杂度是O(N^2)，空间复杂度是O(1)。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve5_1(nums):</span><br><span class="line">    result = 0</span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        k = solve1_2(nums[:i+1]) + solve1_2(nums[i:])</span><br><span class="line">        if result &lt; k:</span><br><span class="line">            result = k</span><br><span class="line">    return result</span><br><span class="line">#print(solve5_1([1, 2, 1, 3, 0, 4]))</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">第二种方式:</span><br><span class="line">不同于Best Time to Buy and Sell Stock I中定义的初始状态A[i]表示第i天卖出挣的最大数目的钱，</span><br><span class="line">这个更进一步直接定义A[i]表示前i天赚的最大数目的钱。minPrice表示从第0天到第i-1天中的最低价格。</span><br><span class="line">A[0]=0。（初始状态）</span><br><span class="line">A[1]=max(prices[1]-prices[0],A[0])</span><br><span class="line">A[2]=max(prices[2]-minPrice,A[1])</span><br><span class="line">即A[i]=max(price[i]-minPrice,A[i-1]).</span><br><span class="line">A[0]=0</span><br><span class="line">另外一次扫描从数组后向前扫描，</span><br><span class="line">定义B[i]表示从第i天到最后一天n能赚的最大数目的钱。maxPrice表示第i+1天到n天的最高价格。</span><br><span class="line">B[n]=0。（初始状态）</span><br><span class="line">B[n-1]=max(maxPrice-prices[n-1],B[n])</span><br><span class="line">B[n-2]=max(maxPrice-prices[n-2],B[n-1])</span><br><span class="line">即B[i]=max(maxPrice-prices[i],B[i+1])</span><br><span class="line">B[n]=0</span><br><span class="line">那么以第i天为分割点能赚的最多数目的钱为A[i]+B[i]</span><br><span class="line">问题的解为max&#123;A[i]+B[i]&#125;。0&lt;=i&lt;=n。</span><br><span class="line">时间复杂度是O(N)，空间复杂度是O(N)。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve5_2(nums):</span><br><span class="line">    result = 0</span><br><span class="line">    A = [0]*len(nums)</span><br><span class="line">    minn = nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        if nums[i-1] &lt; minn:</span><br><span class="line">            minn = nums[i-1]</span><br><span class="line">        A[i] = max(nums[i] - minn, A[i-1])</span><br><span class="line">    B = [0] * len(nums)</span><br><span class="line">    end = len(nums)</span><br><span class="line">    maxx = nums[end-1]</span><br><span class="line">    for i in range(end-2, -1, -1):</span><br><span class="line">        if nums[i+1] &gt; maxx:</span><br><span class="line">            maxx = nums[i+1]</span><br><span class="line">        B[i] = max(maxx-nums[i], B[i+1])</span><br><span class="line">    #result = map(lambda x,y:x+y, A, B)</span><br><span class="line">    result = [A[i]+B[i] for i in range(len(A))]</span><br><span class="line">    return max(result)</span><br><span class="line">#print(solve5_2([1, 2, 1, 3, 0, 4]))</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">最优化:时间复杂度O(n)，空间复杂度O(1)。</span><br><span class="line">第三种解法的核心是假设手上最开始只有0元钱，</span><br><span class="line">那么如果买入股票的价格为price，手上的钱需要减去这个price，</span><br><span class="line">如果卖出股票的价格为price，手上的钱需要加上这个price。</span><br><span class="line">它定义了4个状态：</span><br><span class="line">Buy1[i]表示前i天做第一笔交易买入股票后剩下的最多的钱；</span><br><span class="line">Sell1[i]表示前i天做第一笔交易卖出股票后剩下的最多的钱；</span><br><span class="line">Buy2[i]表示前i天做第二笔交易买入股票后剩下的最多的钱；</span><br><span class="line">Sell2[i]表示前i天做第二笔交易卖出股票后剩下的最多的钱；</span><br><span class="line">那么Sell2[i]=max&#123;Sell2[i-1],Buy2[i-1]+prices[i]&#125;</span><br><span class="line">       Buy2[i]=max&#123;Buy2[i-1],Sell1[i-1]-prices[i]&#125;</span><br><span class="line">       Sell1[i]=max&#123;Sell[i-1],Buy1[i-1]+prices[i]&#125;</span><br><span class="line">       Buy1[i]=max&#123;Buy[i-1],-prices[i]&#125;</span><br><span class="line">可以发现上面四个状态都是只与前一个状态有关，所以可以不使用数组而是使用变量来存储即可。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve5_3(nums):</span><br><span class="line">    sell1 = 0</span><br><span class="line">    buy1 = -nums[0]</span><br><span class="line">    sell2 = 0</span><br><span class="line">    buy2 = 0</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        buy1 = max(buy1, -nums[i])</span><br><span class="line">        sell1 = max(sell1, buy1+nums[i])</span><br><span class="line">        buy2 = max(buy2, sell1-nums[i])</span><br><span class="line">        sell2 = max(sell2, buy2+nums[i])</span><br><span class="line">    return sell2</span><br><span class="line">#print(solve5_3([1, 2, 1, 3, 0, 4]))</span><br><span class="line"></span><br><span class="line">################################## 6.买卖小于等于2次 #########################################</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">最多买两次就是第二种问题的一个变形，求买卖1次和买卖2次最大值，我们用solve4_2作为baseline来改造</span><br><span class="line">时间复杂度O(n),</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def solve6_1(nums):</span><br><span class="line">    result = 0</span><br><span class="line">    A = [0]*len(nums)###存从初始到第i天最大的收益</span><br><span class="line">    minn = nums[0]</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        if nums[i-1] &lt; minn:</span><br><span class="line">            minn = nums[i-1]</span><br><span class="line">        A[i] = max(nums[i] - minn, A[i-1])</span><br><span class="line">    B = [0] * len(nums)### 存从第i天开始到最后一天的最大收益</span><br><span class="line">    end = len(nums)</span><br><span class="line">    maxx = nums[end-1]</span><br><span class="line">    for i in range(end-2, -1, -1):</span><br><span class="line">        if nums[i+1] &gt; maxx:</span><br><span class="line">            maxx = nums[i+1]</span><br><span class="line">        B[i] = max(maxx-nums[i], B[i+1])</span><br><span class="line"></span><br><span class="line">    result = [A[i]+B[i] for i in range(len(A))]</span><br><span class="line">    return max(max(result), max(A))</span><br><span class="line">#print(solve6_1([1, 2, 1, 3, 0, 4]))</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">也用solve5_3作为baseline来改造</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve6_2(nums):</span><br><span class="line">    sell1 = 0</span><br><span class="line">    buy1 = -nums[0]</span><br><span class="line">    sell2 = 0</span><br><span class="line">    buy2 = 0</span><br><span class="line">    for i in range(1, len(nums)):</span><br><span class="line">        buy1 = max(buy1, -nums[i])</span><br><span class="line">        sell1 = max(sell1, buy1+nums[i])</span><br><span class="line">        buy2 = max(buy2, sell1-nums[i])</span><br><span class="line">        sell2 = max(sell2, buy2+nums[i])</span><br><span class="line">    return max(sell2, sell1)</span><br><span class="line">#print(solve6_2([1, 2, 1, 3, 0, 4]))</span><br><span class="line"></span><br><span class="line">################################## 7.买卖小于等于k次 #########################################</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">采用两种方法 均采用动态规划 复杂度相同： 时间复杂度O(n*k)，空间复杂度O(n) </span><br><span class="line">https://blog.csdn.net/smile_watermelon/article/details/47445981</span><br><span class="line"></span><br><span class="line">第一种：</span><br><span class="line"></span><br><span class="line">这里我们需要两个递推公式来分别更新两个变量local和global，我们其实可以求至少k次交易的最大利润。</span><br><span class="line">定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。</span><br><span class="line">定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local[i][j] = max(global[i-1][j-1]+max(diff,0), local[i-1][j]+diff); </span><br><span class="line">global[i][j] = max(local[i][j], global[i-1][j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local[i][j] = max(global[i-1][j-1]+max(diff,0), local[i-1][j]+diff)</span><br><span class="line">需要看两个量，第一个是全局global到i-1天进行j-1次交易，然后加上今天的交易，</span><br><span class="line">如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天）；</span><br><span class="line">第二个量则是取local第i-1天j次交易，然后加上今天的差值</span><br><span class="line">（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，</span><br><span class="line">并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，</span><br><span class="line">因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">global[i][j] = max(local[i][j], global[i-1][j])</span><br><span class="line">即，到第i天完成j次交易的最大收益，要么是第j次交易发生在第i天时的最大收益，</span><br><span class="line">要么是到第i-1天完成j次交易时的最大收益。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果k&gt;len(nums) 则问题退化成 问题2</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def solve7_1(nums, k):</span><br><span class="line"></span><br><span class="line">    if k == 0 or len(nums) ==0:</span><br><span class="line">        return 0</span><br><span class="line">    n = len(nums)</span><br><span class="line">    if k &gt; n:</span><br><span class="line">        ###退化成solve2_1</span><br><span class="line">        summ = 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            diff = nums[i]- nums[i-1]</span><br><span class="line">            summ+= max(0, diff)</span><br><span class="line">        return summ</span><br><span class="line">    else:</span><br><span class="line">        ### 行取 n  列取 k+1  因为交易笔数需要从1-k,第0列作为递推条件必须有</span><br><span class="line">        local = [[0]*(k+1) for _ in range(n)]</span><br><span class="line">        globall = [[0]*(k+1) for _ in range(n)]</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            diff = nums[i]-nums[i-1]</span><br><span class="line">            for j in range(1, k+1):</span><br><span class="line">                local[i][j] = max(globall[i-1][j-1]+max(diff, 0), local[i-1][j]+diff)</span><br><span class="line">                globall[i][j] = max(local[i][j], globall[i-1][j])</span><br><span class="line">        return globall[n-1][k]</span><br><span class="line"></span><br><span class="line">#print(solve7_1([2,4,1],2))</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 股票问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋招面经--作业帮机器学习岗位</title>
      <link href="/2018/09/01/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F--%E4%BD%9C%E4%B8%9A%E5%B8%AE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/09/01/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F--%E4%BD%9C%E4%B8%9A%E5%B8%AE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>秋招面经--作业帮机器学习算法岗位</h2><p>比较少， 合起来整理。</p><hr><h3>作业帮 一面</h3><ul><li><p>1.自我介绍。</p></li><li><p>2.JD项目介绍，讲了一下如何分布式构建问题。</p></li><li><p>3.项目里faster-rcnn原理， 损失函数。</p></li><li><p>4.比赛里用到的xgboost的分裂规则，其中xgboost里有model.get_fscore()方法，得分机制是什么?(所有决策树的特征和进行排序)</p></li><li><p>5.树模型和svm，lr的区别？ 为什么svm和lr要进行特征归一化。</p></li><li><p>6.lr是线性分类器吗？https://www.zhihu.com/question/29385169<img src="https://github.com/Buevara/blog_img/raw/master/9.1/9.1-1.png" alt="9.1-1"></p></li><li><p>7.算法3道题：</p></li><li><p>7.1 nums里面元素乘积小于K的子区间个数？ 滑窗法https://www.cnblogs.com/grandyang/p/7753959.html<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums, k):</span><br><span class="line">        if k &lt;=1:</span><br><span class="line">            return 0</span><br><span class="line">        count = 0</span><br><span class="line">        t = 1</span><br><span class="line">        start = 0</span><br><span class="line">        for j in range(0, len(nums)):</span><br><span class="line">            t *= nums[j]</span><br><span class="line">            while t &gt;= k:</span><br><span class="line">                t /= nums[start]</span><br><span class="line">                start += 1</span><br><span class="line">            count += j-start+1</span><br><span class="line">        return count</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.search([10, 5, 2, 6], 100))</span><br></pre></td></tr></table></figure></p></li><li><p>7.2 长度为n的数组，其中所有数都小于等于n大于0，求重复值和缺失值</p></li><li><p>7.3 有序二维矩阵中第K小的元素  https://blog.csdn.net/weixin_39915444/article/details/80732634<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums, k):</span><br><span class="line">        left = nums[0][0]</span><br><span class="line">        right = nums[len(nums)-1][len(nums[0])-1]</span><br><span class="line">        while (left &lt;= right):</span><br><span class="line">            mid = (left+right)//2</span><br><span class="line">            count = self.tocount(nums, mid)</span><br><span class="line">            if count &gt;= k:</span><br><span class="line">                right = mid -1 </span><br><span class="line">            if count &lt; k:</span><br><span class="line">                left = mid + 1</span><br><span class="line">        return mid</span><br><span class="line">        </span><br><span class="line">    def tocount(self, nums, mid):</span><br><span class="line">        count = 0</span><br><span class="line">        i = len(nums)-1</span><br><span class="line">        j = 0</span><br><span class="line">        while i &gt;=0 and j&lt;len(nums[0]):</span><br><span class="line">            if nums[i][j] &lt;= mid:</span><br><span class="line">                count += i+1</span><br><span class="line">                j += 1</span><br><span class="line">            else:</span><br><span class="line">                i -= 1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋招面经--360机器学习岗位</title>
      <link href="/2018/08/24/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F--360%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/08/24/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F--360%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>秋招面经--360机器学习算法岗位</h2><hr><p>一站式服务只享受了第一站，说来很羞愧。</p><hr><h3>一面</h3><ul><li>1.自我介绍。</li><li>2.JD项目介绍，讲了一下如何分布式构建问题。</li><li>3.CNN流程，如何进行卷积，如何pooling，什么是权值共享，哪些权值不共享，为什么感受野越来越大？为什么是从细节到整体？</li><li>4.激活函数有什么，优缺点？</li><li>5.逻辑斯底回归如何求最小loss，为什么要加log（不会，面试官回答是要消除e，防止产生梯度的爆炸或者消失）什么是最大似然，如何推导的？</li><li>6.挑项目里的算法讲一讲，选了gbdt和xgboost，其中梯度下降法和牛顿法的差别？就是牛顿法用了二阶导数，二梯度下降只用了一阶导数</li><li>7.算法二选一：快排和2sum</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--树模型的三种分列方式</title>
      <link href="/2018/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A0%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%86%E8%A3%82%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A0%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%86%E8%A3%82%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2>树模型的三种分列方式</h2><p>分别是利用信息增益的ID3算法，利用信息增益比的C4.5算法和利用基尼系数的CART树。<img src="https://github.com/Buevara/blog_img/raw/master/8.19/0.png" alt="0"></p><hr><h3>1.ID3算法</h3><p>ID3算法规定变量必须是离散值，且可以有多个分支（多叉树），而且不进行剪枝操作。且容易过拟合。<img src="https://github.com/Buevara/blog_img/raw/master/8.19/1-4.png" alt="1-4">例如：</p><p><img src="https://github.com/Buevara/blog_img/raw/master/8.19/1-1.png" alt="1-1">先求出信息熵（经验熵）:<img src="https://github.com/Buevara/blog_img/raw/master/8.19/1-2.png" alt="1-2">再根据不同的特征求出经验条件熵：<img src="https://github.com/Buevara/blog_img/raw/master/8.19/1-3.png" alt="1-3">其中：H(活动|天气) = 5/14*((-2/5)*log(2/5)+((-3/5)<em>log(3/5)))+4/14</em>((-4/4)<em>log(4/4)) + 5/14</em>((-2/5)*log(2/5)+((-3/5)*log(3/5)))<img src="https://github.com/Buevara/blog_img/raw/master/8.19/1-5.png" alt="1-5">最后构造：<img src="https://github.com/Buevara/blog_img/raw/master/8.19/1-6.png" alt="1-6">g(活动|天气) = H(活动)-H(活动|天气)</p><h3>2.C4.5算法</h3><p>ID3采用的信息增益度量存在一个缺点，它一般会优先选择有较多属性值的Feature,因为属性值多的Feature会有相对较大的信息增益(信息增益反映的给定一个条件以后不确定性减少的程度,必然是分得越细的数据集确定性更高,也就是条件熵越小,信息增益越大).为了避免这个不足C4.5中是用信息增益比率(gain ratio)来作为选择分支的准则。信息增益比率通过引入一个被称作分裂信息(Split information)的项来惩罚取值较多的Feature。除此之外，C4.5还弥补了ID3中不能处理特征属性值连续的问题。C4.5可以处理连续变量，也可以进行多叉树，引入分裂信息进行惩罚。也进行剪枝。可以处理缺失值，分为赋最常见值或丢弃缺失样本。由于处理连续值需要对特征值排序，所以比ID3慢。<img src="https://github.com/Buevara/blog_img/raw/master/8.19/2-1.png" alt="2-1">如上例所示：g(活动|天气) = H(活动)-H(活动|天气)gainratio(活动|天气) = g(活动|天气) / Ha(活动)Ha(活动) = -(5/14<em>log(5/14)) +(-(4/14</em>log(4/14))) +(-5/14*log(5/14))</p><h3>3.CART</h3><p>CART即可以回归又可以分类，必须是二叉树。<img src="https://github.com/Buevara/blog_img/raw/master/8.19/3-1.png" alt="3-1">对于二分类：Gini（P）= 2p(1-p)</p><h3>4.决策树的剪枝</h3><p>没找到好的答案，稍后补上。</p><h3>5.分类树 VS 回归树</h3><p>提到决策树算法，很多想到的就是上面提到的ID3、C4.5、CART分类决策树。其实决策树分为分类树和回归树，前者用于分类，如晴天/阴天/雨天、用户性别、邮件是否是垃圾邮件，后者用于预测实数值，如明天的温度、用户的年龄等。</p><p>作为对比，先说分类树，我们知道ID3、C4.5分类树在每次分枝时，是穷举每一个特征属性的每一个阈值，找到使得按照feature&lt;=阈值，和feature&gt;阈值分成的两个分枝的熵最大的feature和阈值。按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。</p><p>回归树总体流程也是类似，不过在每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准<strong>不再是最大熵，而是最小化均方差</strong>--即（每个人的年龄-预测年龄）^2 的总和 / N，或者说是每个人的预测误差平方和 除以 N。这很好理解，被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最靠谱的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件（如叶子个数上限），若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。回归树具体参考(https://blog.csdn.net/weixin_40604987/article/details/79296427)参考:https://www.cnblogs.com/wxquare/p/5379970.htmlhttps://wenku.baidu.com/view/7aa9fbd776eeaeaad1f3305d.html<img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-15.png" alt="4.18-15"></p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 树模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习基础--BN层的作用详解</title>
      <link href="/2018/06/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80--BN%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80--BN%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1>深度学习基础--BN层的作用详解.md</h1><p><a href="https://blog.csdn.net/myarrow/article/details/51848285" target="_blank" rel="noopener">详情见cs231n学习笔记-激活函数-BN-参数优化</a></p>]]></content>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--排序算法复杂度总结</title>
      <link href="/2018/06/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1>算法基础--排序算法复杂度总结</h1><p><img src="https://github.com/Buevara/blog_img/raw/master/8.11/1-1.png" alt="1-1"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--背包问题(下篇)</title>
      <link href="/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%8B%E7%AF%87)/"/>
      <url>/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%8B%E7%AF%87)/</url>
      <content type="html"><![CDATA[<h1>算法基础--背包问题(下篇)</h1><p>背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。本篇是下篇：主要讨论求解满足背包最优的解决方案。</p><hr><h3>11. 0-1背包满足最大条件的最优方案问题</h3><blockquote><p>问题描述：m是背包的容量。n个物品，A表示物品重量，V表示物品的价值。 计算出的装入背包物品的最大价值和最优装入方案输出。例如：10, [4,2,5],[6,1,2]结果：81 0 1</p></blockquote><p>解题思路：</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##当计算完dp之后（求得了最优值之后），进行回溯，只回溯dp[x][m]</span></span><br><span class="line">        <span class="comment">### res表示最终的结果</span></span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackI</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        print(res)</span><br><span class="line">            </span><br><span class="line">a = Solution()</span><br><span class="line">a.backPackI(<span class="number">10</span>, [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure></p><hr><h3>12. 完全背包满足最大条件的最优方案问题</h3><blockquote><p>问题描述：m是背包的容量。n个物品，A表示物品重量，V表示物品的价值。每个物品可以用无限次， 计算出的装入背包物品的最大价值和最优装入方案输出。例如：m=11, A=[2,3,5,7], V=[1,5,2,4]结果： 16   [1, 3, 0, 0]</p></blockquote><p>解题思路：</p><blockquote></blockquote><p>和上面的题的思路是一样的，但是需要考虑：</p><ol><li>将完全背包转换为0-1背包，也就是改变A和V使用newMatrix函数</li><li>得到了res之后如何切分成原始A的数量用recover函数例如：A原始是:[2,3,5,7]newMatrix之后是:[2, 4, 6, 8, 10, 3, 6, 9, 5, 10, 7]res得到:[1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]recover之后：[1, 3, 0, 0]</li></ol><blockquote></blockquote><p>1.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a)</span>:</span></span><br><span class="line">        j = m//a</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend(A[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">            v.extend(V[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        A = a</span><br><span class="line">        print(A)</span><br><span class="line">        V = v</span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        print(res)</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><p>2.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil) $)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, k)</span>:</span></span><br><span class="line">        n = m//k</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ) </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        print(res)</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><p>结果： 16  [1, 3, 0, 0]</p><hr><h3>13. 多重背包满足最大条件的最优方案问题</h3><blockquote><p>问题描述：m是背包的容量。n个物品，A表示物品重量，V表示物品的价值,nk表示物品可用的次数， 计算出的装入背包物品的最大价值和最优装入方案输出。例如：m=11, A=[2,3,5,7], V=[1,5,2,4]结果： 16   [1, 3, 0, 0]</p></blockquote><p>解题思路：</p><p>和上题完全背包类似， 只是求$min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$ 或 $min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)$</p><p>1.时间复杂度O($m*(\sum_{i= 0}^{n-1}*min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a, k)</span>:</span></span><br><span class="line">        j = m//a</span><br><span class="line">        j = min(j, k)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i], nk[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend(A[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">            v.extend(V[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        A = a</span><br><span class="line">        print(A)</span><br><span class="line">        V = v</span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>2.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)) $)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a, k)</span>:</span></span><br><span class="line">        n = m//a</span><br><span class="line">        n = min(n, k)</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, tmp, res)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            summ = <span class="number">0</span></span><br><span class="line">            aa, ii = tmp[i][<span class="number">0</span>],tmp[i][<span class="number">1</span>]</span><br><span class="line">            ss = res[:len(ii)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                <span class="keyword">if</span> ss[i] == <span class="number">1</span>:</span><br><span class="line">                    summ += ii[i]</span><br><span class="line">            res = res[len(ii):]</span><br><span class="line">            result.append(summ) </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i], nk[i])</span><br><span class="line">            tmp.append((A[i], nums))</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp[x][m])</span><br><span class="line">        res = [<span class="number">0</span>]*x</span><br><span class="line">        j = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">                j -= A[i<span class="number">-1</span>]</span><br><span class="line">        result = self.recover(tmp, res)</span><br><span class="line">        print(result)</span><br><span class="line">q = Solution()</span><br><span class="line">q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>结果：15   [0, 3, 0, 0]</p><hr><p>(全篇结束，如果有问题可以留言讨论)</p><p>参考文献：[1] https://www.kancloud.cn/kancloud/pack/70125[2] https://www.jiuzhang.com[3] https://blog.csdn.net/luoshengkim/article/details/X6514558</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--背包问题(中篇)</title>
      <link href="/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%AD%E7%AF%87)/"/>
      <url>/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%AD%E7%AF%87)/</url>
      <content type="html"><![CDATA[<h1>算法基础--背包问题(中篇)</h1><p>背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。本篇是中篇：主要讨论背包计数问题。</p><hr><h3>6. 0-1背包计数问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。每件大小是A[i]，每个物品只能用1次，问有多少种方法把它装满？例如： n=3， A=[1,2,4], m=11</p></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-7.png" alt="5.19-7"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackNumI</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">###dp[0][0] == 1 所以dp[1][0]...dp[x][0] 都等于1</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> range(x+<span class="number">1</span>):</span><br><span class="line">            dp[ii][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackNumI(<span class="number">12</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure></p><p>结果： 1  只有3+2+7=12 一种情况</p><hr><h3>7. 完全背包计数问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。每件大小是A[i]，每个物品能用无限次，问有多少种方法把它装满？例如： n=4， A=[2,3,5,7], m=11</p></blockquote><p>解题思路：</p><p>State:dp[i][j] 前i个物品正好放入j中的方案数量DP Function:dp[i][j] = dp[i - 1][j] + dp[i - 1][j - A[i-1] * 1] + dp[m - 1][j - A[i-1] * 2] + dp[i - 1][j - A[i-1] * 3] + ...Initialize:dp[0][0] = 1时间复杂度：O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackNumII</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]*v]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackNumII(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：4   分别为(1,1,1,1),(1,1,2),(2,2),(4)</p><hr><h3>8. 多重背包计数问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。每件大小是A[i]，每个物品只能用nk次，问有多少种方法把它装满？例如： n=3， A=[1,2,4], nk=[2,2,3], m=4</p></blockquote><p>解题思路：</p><p>时间复杂度：时间复杂度O($m*(\sum_{i= 0}^{n-1}*min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$)就是求：$min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor)$<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackNumII</span><span class="params">(self, m, A, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                k = min(k, nk[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]*v]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackNumII(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：3  分别为(1,1,2),(2,2),(4)</p><hr><h3>9. 0-1背包计数变形I的问题</h3><blockquote><p>问题描述：从一个数组中取k个数的和为target，求有多少种组合。假如数组是[1,2,3,4], k = 2, target = 5。那么有2种解：[1,4] 和 [2,3]。</p></blockquote><p>解题思路：state:f[i][j][t]前 i 个数中取 j 个数出来组成和为 t 的组合数目function:f[i][j][t] = f[i - 1][j][t] + f[i - 1][j - 1][t - a[i - 1]] (不包括第i 个数的时候组成t的情况 + 包括第i个数的时候组成t的情况)initialize:f[i][0][0] = 1result:f[n][k][target]</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newbackPackI</span><span class="params">(self, m, A, k)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)] </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x+<span class="number">1</span>):</span><br><span class="line">            print(i)</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">0</span>, m+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j][o] = dp[i<span class="number">-1</span>][j][o]</span><br><span class="line">                    <span class="keyword">if</span> o -A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                        dp[i][j][o] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>][o-A[i<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[x][k][m]</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.newbackPackI(<span class="number">5</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>结果：2</p><hr><h3>10. 完全背包计数变形I问题</h3><blockquote><p>问题描述：给定一个包含了一些数字的数组，和一个目标值，从数组里面取数做排列，使得排列的数字的和等于target。问有多少种排列方法。数字是阔以重复取出来的。比如给定数组[1, 2, 4]和target值4。那么能得到如下的组合。总共有6种，则返回6.</p></blockquote><p>结果：[1, 1, 1, 1][1, 1, 2][1, 2, 1][2, 1, 1][2, 2][4]</p><blockquote></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-8.png" alt="5.19-8"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newbackPackI</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> i-s &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] += dp[i-s]</span><br><span class="line">        <span class="keyword">return</span> dp[m]</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.newbackPackI(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：6</p><hr><p>(中篇结束，接下来的下篇将讨论求解满足背包最优的解决方案)</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--背包问题(上篇)</title>
      <link href="/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%8A%E7%AF%87)/"/>
      <url>/2018/05/19/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98(%E4%B8%8A%E7%AF%87)/</url>
      <content type="html"><![CDATA[<h1>算法基础--背包问题(上篇)</h1><p>背包问题是面试中非常常见的考点，今天整理一下。由于篇幅过长，所以分成上、中、下三篇进行分析。本篇是上篇：主要讨论背包问题的最优解问题。</p><hr><h3>1. 0-1背包问题</h3><blockquote><p>问题1描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]例如：m= 11 n=4 A=[2，3，5，7]</p></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-1.png" alt="5.19-1"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">###复杂度是O(n*m)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">###我们的物品设置从1开始，所以A[i-1]                </span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+A[i<span class="number">-1</span>])    </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br></pre></td></tr></table></figure></p><p>用1维数组：注意： j 的顺序是(m, 0, -1)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack</span><span class="params">(self, m, A)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-A[i<span class="number">-1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-A[i<span class="number">-1</span>]]+A[i<span class="number">-1</span>])  <span class="comment">###我们的物品设置从1开始，所以A[i-1]</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = dp[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m]</span><br></pre></td></tr></table></figure></p><blockquote><p>问题2描述：给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？例如：m= 11 n=4 A=[2，3，5，7]， V=[1, 5, 2, 4]</p></blockquote><p>解题思路：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-2.png" alt="5.19-2"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">###复杂度是O(n*m)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackI</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br></pre></td></tr></table></figure></p><hr><h3>2.完全背包问题（无限背包问题）</h3><blockquote><p>问题描述：有n种物品和一个容量为m的背包，每种物品都有无限件可用。第i种物品的空间是A[i]，价值是V[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。例如： n=4， A=[2,3,5,7], V = [1,5,4,2], m=11解题思路：1.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $)<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-3.png" alt="5.19-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                    tmp = [dp[i<span class="number">-1</span>][j-t*A[i<span class="number">-1</span>]]+t*V[i<span class="number">-1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>)]</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],max(tmp))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p></blockquote><p>变形一下，方便接下来的求最优方案：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, a)</span>:</span></span><br><span class="line">        j = m//a</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            a.extend(A[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">            v.extend(V[i]*k <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        A = a</span><br><span class="line">        V = v</span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                    tmp = [dp[i<span class="number">-1</span>][j-t*A[i<span class="number">-1</span>]]+t*V[i<span class="number">-1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>)]</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],max(tmp))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> (dp[x][m])</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>2.时间复杂度也为O($m*(\sum_{i= 0}^{n-1}*\left \lfloor \frac{m}{A[i]} \right \rfloor) $) 但是换一种写法：<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-4.png" alt="5.19-4"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    <span class="comment">### dp[i-1][j] 和 dp[i][j-A[i-1]]+V[i-1]</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>3.时间复杂度为O($m*(\sum_{i= 0}^{n-1}*\left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil) $)<img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-5.jpeg" alt="5.19-5"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, k)</span>:</span></span><br><span class="line">        n = m//k</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i])</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：16</p><hr><h3>3.多重背包问题</h3><blockquote><p>问题描述：n种物品和一个容量为m的背包。第i种物品最多有nk[i]件可用，每件大小是A[i]，价值是V[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。例如： n=4， A=[2,3,5,7], V = [1,5,4,2], nk = [2,3,4,5],  m=11</p></blockquote><p>解题思路：</p><ol><li>时间复杂度O($m*(\sum_{i= 0}^{n-1}*min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$)</li></ol><p>完全背包的变种， 求$min(nk[i],\left \lfloor \frac{m}{A[i]} \right \rfloor))$</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackIII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    k = j//A[i<span class="number">-1</span>]</span><br><span class="line">                    k = min(k, nk[i<span class="number">-1</span>])</span><br><span class="line">                    tmp = [dp[i<span class="number">-1</span>][j-t*A[i<span class="number">-1</span>]]+t*V[i<span class="number">-1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>)]</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],max(tmp))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackIII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure></p><ol start="2"><li>时间复杂度为O($m*(\sum_{i= 0}^{n-1}*min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)) $)完全背包的变种， 求$min(nk[i], \left \lceil log_{2}^{\left \lfloor \frac{m}{A[i]} \right \rfloor} \right \rceil)$</li></ol><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newMatrix</span><span class="params">(self, m, k, nk)</span>:</span></span><br><span class="line">        n = m//k</span><br><span class="line">        n = min(nk, n)</span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pow(<span class="number">2</span>, idx) &lt;= n:</span><br><span class="line">            res.append(pow(<span class="number">2</span>, idx))</span><br><span class="line">            n -= pow(<span class="number">2</span>, idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n!=<span class="number">0</span>:</span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackIII</span><span class="params">(self, m, A, V, nk)</span>:</span></span><br><span class="line">        x = len(A)</span><br><span class="line">        a = []</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            nums = self.newMatrix(m, A[i], nk[i])</span><br><span class="line">            a.extend([y*A[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">            v.extend([y*V[i] <span class="keyword">for</span> y <span class="keyword">in</span> nums])</span><br><span class="line">        A, V = a, v</span><br><span class="line">        x = len(A)   </span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - A[i<span class="number">-1</span>] &gt;=<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]]+V[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[x][m]</span><br><span class="line">q = Solution()</span><br><span class="line">print(q.backPackIII(<span class="number">11</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure></p><p>结果：16</p><hr><h3>4.混合三种背包问题</h3><p>就是上面的三种问题的混合，具体不再赘述。</p><hr><h3>5.分组的背包问题</h3><p><img src="https://github.com/Buevara/blog_img/raw/master/5.19/5.19-6.png" alt="5.19-6"></p><hr><p>(上篇结束，接下来的中篇将讨论背包计数问题)</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--知乎算法岗位</title>
      <link href="/2018/05/04/%E9%9D%A2%E7%BB%8F--%E7%9F%A5%E4%B9%8E%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/05/04/%E9%9D%A2%E7%BB%8F--%E7%9F%A5%E4%B9%8E%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>面经--知乎算法岗位</h2><hr><h3>一面：</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.聊项目，xgboost和gbdt的差别？</p></li><li><p>3.验证集的作用？</p></li><li><p>4.什么是过拟合？如何解决过拟合？</p></li><li><p>5.L1正则和L2正则？</p></li><li><p>6.Droputout的含义？</p></li><li><p>7.BN层的含义？</p></li><li><ol start="8"><li>AUC,ROC的含义？</li></ol></li><li><ol start="9"><li>Inception和Resnet的区别？</li></ol></li><li><p>10.算法：</p><ol><li>旋转数组中的最小值？(剑指offer)</li><li>单词dog转换为tik,有词库voc。 我用了队列，他说不是最优的</li></ol></li></ul><hr><h3>二面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.项目中，xgboost和gbdt区别？</p></li><li><p>3.随机森林中的随机指的是什么？</p></li><li><p>4.gbdt的参数有哪些，如何调整？</p></li><li><p>5.树模型的深度和树的数量有什么关系？</p></li><li><p>6.BN层的作用？</p></li><li><p>7.会不会hive，hadoop？ 不会</p></li><li><p>8.词向量word2vec？ 没学过</p></li><li><p>9.协同过滤？</p></li><li><p>10.算法:</p><ol><li>无序数组 知道排序前和排序后的相对位置差的绝对值k，如何比快速排序的时间复杂度还低？ 堆排序，直接取k个初始，构建最小堆，每次取堆顶元素。</li><li>翻转链表的前x个元素？</li></ol></li></ul><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--XGBOOST和GBDT的知识点整理</title>
      <link href="/2018/04/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--XGBOOST%E5%92%8CGBDT%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2018/04/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--XGBOOST%E5%92%8CGBDT%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2>机器学习--XGBOOST和GBDT的知识点整理</h2><hr><h3>1.树模型缺失值</h3><p>树模型：如何处理缺失值：按照我自己的理解就是：在属性a下假如存在缺失值的话，在计算属性a下的信息增益或者信息增率时，把具有缺失值的元组去掉，把具有完整值的属性a代入计算，用去掉缺失值计算结果进行比较。</p><p>如图，假设有100个样本，针对属性A，有20个样本是缺失值。树模型处理缺失样本的时候，会先忽略属性A缺失的样本，然后采用某种属性选择度量（信息增益、增益率、基尼指数）对剩下的样本（现在有80个）进行分裂。假设将这80个样本分裂到图中的三个节点，三个节点分配到的样本数分别为30、25、25（称这个过程为过程一）。然后将属性A缺失的20个样本均加入到这三个节点中（称这个过程为过程二）。在过程一中加入节点的样本的权值均为1，而在过程二中加入节点的样本的权值为：该节点中属性A未缺失的样本数/父节点中属性A未缺失的样本数，如属性A缺失的样本添加到节点1之后的权重为 30/80 = 0.375。<img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-5.png" alt="4.18-5"></p><h3>2.为什么树模型不需要归一化特征？</h3><p>概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率。像svm、线性回归之类的最优化问题就需要归一化。决策树属于前者。</p><h3>3.xgboost</h3><p>https://blog.csdn.net/github_38414650/article/details/76061893</p><h3>4.为什么xgboost比gbdt更快？</h3><p>https://www.zhihu.com/question/41354392http://idatamining.net/blog/?p=1901</p><blockquote><p>1.可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。利用直方图的离散，找到最优的切分点。</p></blockquote><blockquote><p>2.既提供了单机多线程并行加速，也支持多机分布式加速。也就提供了若干种不同的并行建树的updater实现，按并行策略的不同，包括：<br>I). inter-feature exact parallelism （特征级精确并行）   II). inter-feature approximate parallelism（特征级近似并行，基于特征分bin计算，减少了枚举所有特征分裂点的开销）<br>III). intra-feature parallelism （特征内并行）IV). inter-node parallelism  （多机并行）</p></blockquote><blockquote><p>3.把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在 遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p><p>4.xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-13.png" alt="4.18-13"><img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-14.png" alt="4.18-14"><img src="https://github.com/Buevara/blog_img/raw/master/4.18/4.18-15.png" alt="4.18-15"></p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 树模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--360机器学习算法岗位</title>
      <link href="/2018/04/24/%E9%9D%A2%E7%BB%8F--360%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%EF%BC%88%E4%BA%8C%E9%9D%A2%E6%8C%82%EF%BC%89/"/>
      <url>/2018/04/24/%E9%9D%A2%E7%BB%8F--360%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%EF%BC%88%E4%BA%8C%E9%9D%A2%E6%8C%82%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2>面经--360机器学习算法岗位（二面挂）</h2><hr><h3>一面：</h3><ul><li>1.自我介绍.</li><li>2.问了所有的项目经历。</li><li>3.算法：大数据下找到两个人的共同好友？<a href="https://blog.csdn.net/u012808902/article/details/77513188" target="_blank" rel="noopener">澈彻策的博客</a><img src="https://github.com/Buevara/blog_img/raw/master/4.26/4.26-3.png" alt="4.26-3"></li></ul><hr><h3>二面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.SVM为什么特征需要归一化？</p></li></ul><p>首选，什么是归一化？什么是标准化？！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-1.png" target="_blank" rel="noopener">4.25-1</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-2.png" target="_blank" rel="noopener">4.25-2</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-3.png" target="_blank" rel="noopener">4.25-3</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-4.png" target="_blank" rel="noopener">4.25-4</a>！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-5.png" target="_blank" rel="noopener">4.25-5</a></p><p>SVM的调参值？C和g： cost和gammagamma（或Epsilon ε）---不敏感损失函数的参数，gamma越大，支持向量越少，gamma值越小，支持向量越多，RBF宽度越大</p><p>C 惩罚系数，C过大或过小，泛化能力变差！<a href="https://github.com/Buevara/blog_img/raw/master/4.25/4.25-6.png" target="_blank" rel="noopener">4.25-6</a><a href="https://blog.csdn.net/wusecaiyun/article/details/49681431" target="_blank" rel="noopener">参考链接</a>https://www.zhihu.com/question/20455227</p><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--阿里巴巴机器学习岗位</title>
      <link href="/2018/04/19/%E9%9D%A2%E7%BB%8F--%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%EF%BC%88%E4%B8%80%E9%9D%A2%E6%8C%82%EF%BC%89/"/>
      <url>/2018/04/19/%E9%9D%A2%E7%BB%8F--%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%EF%BC%88%E4%B8%80%E9%9D%A2%E6%8C%82%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2>面经--阿里巴巴机器学习算法岗位（一面挂）</h2><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.问了发表过的安全相关的论文（完全没复习，什么也不会）。</p></li><li><p>3.项目上用到了迁移学习，问迁移学习的原理是什么。（一脸懵逼）迁移学习是把一个领域（即源领域）的知识，迁移到另外一个领域（即目标领域），使得目标领域能够取得更好的学习效果。通常，源领域数据量充足，而目标领域数据量较小，迁移学习需要将在数据量充足的情况下学习到的知识，迁移到数据量小的新环境中。</p></li><li><p>4.cnn的激活函数有什么？为什么sigmod函数会出现梯度消失和梯度爆炸？<a href="https://zhuanlan.zhihu.com/p/25631496" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-3.png" alt="4.19-3"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-4.png" alt="4.19-4"></p></li></ul><blockquote><p>解决方案：<a href="https://blog.csdn.net/qq_25737169/article/details/78847691" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-5.png" alt="4.19-5"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-6.png" alt="4.19-6"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-7.png" alt="4.19-7"></p></blockquote><ul><li><p>5.为什么不用传统的三层网络，而使用CNN呢？为什么不能用DNN一直加深去做？<a href="https://www.zhihu.com/question/34681168" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-1.png" alt="4.19-1"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-2.png" alt="4.19-2"></p></li><li><p>6.假如有一张人脸照片，用CNN的卷积提取流程？由浅层特征到深层特征，从纹理，到局部再到全图。每个卷积和只提取一种特征。</p></li><li><p>7.项目中的创新点？</p></li><li><p>8.cnn的权值共享是什么意思？<a href="https://www.zhihu.com/question/47158818" target="_blank" rel="noopener">&lt;-答案点击-&gt;</a></p></li><li><p>9.逻辑斯蒂回归为什么用sigmod函数而不用其他的函数？<img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-8.png" alt="4.19-8"><img src="https://github.com/Buevara/blog_img/raw/master/4.19/4.19-9.png" alt="4.19-9"></p></li></ul><p>一面结束，二十分钟。很多问题没有答上来，真的感觉有些东西从来没想过，面试官认为我的项目工作量过小，基础方面需要加强。</p><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--动态规划解决子序列、子串问题</title>
      <link href="/2018/04/17/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%81%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2018/04/17/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%81%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1>解决最长公共子序列和最长公共子串</h1><p>子串是连续的，子序列是相对位置不变，可以连续，也可以不连续。</p><hr><h2>最长公共子序列问题（Longest Common Subsequence,LCS）</h2><p>下面的字符串也可以是数组，本质上都一样。</p><hr><h3>1.求解两个字符串的最长公共子序列的长度</h3><blockquote><p>问题描述：给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB,则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p></blockquote><p>解题思路：假设字符串分别为x,y,从x和y的最后字母开始看:</p><blockquote><ul><li>x[i]==y[j],则c[i][j] = c[i-1][j-1]c[i,j]表示：(x1,x2....xi) 和 (y1,y2...yj 的最长公共子序列的长度)</li><li>x[i]!=y[j],则分为两种情况c[i-1][j] 和c[i][j-1]我们取 max(c[i-1][j],c[i][j-1])</li></ul></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-1.png" alt="4.17-1">解释一下为什么i或j==0，为什么c[i][j] =0:c[0,j]表示字符串1的长度是0，字符串2的长度是j，这两个字符串的最长公共子序列的长度是？当然是0喽。。。因为，字符串1 根本就没有嘛。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-2.png" alt="4.17-2"></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    m = len(y)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[n][m]</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="string">'bdcaba'</span>,<span class="string">'abcbdab'</span>))</span><br></pre></td></tr></table></figure></p><p>结果是：4</p><hr><h3>2.求解两个字符串的所有最长公共子序列</h3><p>求一个最长子序列的问题是这个问题的简化版，所以不单独考虑了。</p><p>我们用第一种方法得到了dp这个二维数组，记录了最长子串的长度，我们现在用dp来递归寻找所有最大公共子序列。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-3.png" alt="4.17-3"></p><blockquote><p>输出一个最长公共子序列并不难（网上很多相关代码），难点在于输出所有的最长公共子序列，因为 LCS 通常不唯一。总之，我们需要在动态规划表上进行回溯 —— 从dp[m][n]，即右下角的格子，开始进行判断：</p><ol><li>如果格子dp[i][j]对应的x[i-1] ==y[j-1]，则把这个字符放入LCS中，并跳入dp[i-1][j-1]中继续进行判断；</li><li>如果格子dp[i][j]对应的 x[i-1] ≠ y[j-1]，则比较dp[i-1][j]和dp[i][j-1]的值，跳入值较大的格子继续进行判断；</li><li>如果出现dp[i-1][j]等于dp[i][j-1]的情况，说明最长公共子序列有多个，故两边都要进行回溯,这里用到递归。</li></ol><blockquote><ol start="4"><li>直到 i 或 j 小于等于零为止，倒序输出 LCS 。</li></ol></blockquote></blockquote><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        n = len(x)</span><br><span class="line">        m = len(y)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self, x,y,dp, i, j, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i ==<span class="number">0</span> <span class="keyword">or</span> j ==<span class="number">0</span>:</span><br><span class="line">            self.res.append(tmp[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">            self.printf(x, y, dp, i<span class="number">-1</span>, j<span class="number">-1</span>, tmp+x[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] &gt; dp[i][j<span class="number">-1</span>]:</span><br><span class="line">                self.printf(x, y, dp, i<span class="number">-1</span>, j, tmp)</span><br><span class="line">            <span class="keyword">elif</span> dp[i<span class="number">-1</span>][j] &lt; dp[i][j<span class="number">-1</span>]:</span><br><span class="line">                self.printf(x, y, dp, i, j<span class="number">-1</span>, tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.printf(x, y, dp, i, j<span class="number">-1</span>, tmp)</span><br><span class="line">                self.printf(x, y, dp, i<span class="number">-1</span>, j, tmp)</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longest</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        dp = self.solve(x, y)</span><br><span class="line">        self.res = []</span><br><span class="line">        self.printf(x, y, dp, len(x), len(y), <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">a = Solution()</span><br><span class="line">print(a.longest(<span class="string">'dbcab'</span>,<span class="string">'cdab'</span>))</span><br></pre></td></tr></table></figure></p><p>结果：['cab', 'dab']</p><hr><h2>最长公共子串问题</h2><p>下面的字符串也可以是数组，本质上都一样。</p><hr><h3>1.求解两个字符串的最长公共子串的长度</h3><p>子串是子序列的一个特殊形式，所以比求子序列更简单。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-4.png" alt="4.17-4"><img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-5.jpeg" alt="4.17-5"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    m = len(y)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="string">'abc'</span>,<span class="string">'adbc'</span>))</span><br></pre></td></tr></table></figure></p><p>结果：2</p><hr><h3>2.求解两个字符串的所有最长公共子串</h3><p>就是找下图中从最大子串长度开始斜向上到1的对应字符相加，进行翻转就是结果。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-5.jpeg" alt="4.17-5"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    n = len(x)</span><br><span class="line">    m = len(y)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    maxx =  max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == maxx:</span><br><span class="line">                tmp.append([i, j])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> tmp:</span><br><span class="line">        t = <span class="string">''</span></span><br><span class="line">        i,j = k[<span class="number">0</span>],k[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> j<span class="number">-1</span>&gt;=<span class="number">0</span>) <span class="keyword">and</span> x[i<span class="number">-1</span>]==y[j<span class="number">-1</span>]:</span><br><span class="line">            t += x[i<span class="number">-1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        res.append(t)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="string">'adcbc'</span>,<span class="string">'adbc'</span>))</span><br></pre></td></tr></table></figure></p><p>结果：['bc', 'ad']</p><hr><p>拓展：</p><h3>1.最长增长子序列</h3><p><a href="https://www.nowcoder.com/questionTerminal/585d46a1447b4064b749f08c2ab9ce66" target="_blank" rel="noopener">原题链接</a></p><blockquote><p>题目：给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6，7，1，2，8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.</p></blockquote><p>思路：解法1：最长公共子序列法这个问题可以转换为最长公共子序列问题。如例子中的数组A{5，6， 7， 1， 2， 8}，则我们排序该数组得到数组A‘{1， 2， 5， 6， 7，8}，然后找出数组A和A’的最长公共子序列即可。</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">代码请参考第一道题</span><br></pre></td></tr></table></figure></p><p>解法2：动态规划法（时间复杂度O(N^2))</p><blockquote><p>设长度为N的数组为{a0，a1,a2,...an-1)，建立dp二维矩阵如例子所示：假设数组a =[2,1,4,6],建立二维dp数组</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-6.jpg" alt="4.17-6">结果是3，分别是：[1,4,6]和[2,4,6]</p><blockquote><p>1.dp[i]<a href="i=0%EF%BC%8C1%EF%BC%8C2%EF%BC%8C3%EF%BC%8Clen(a)-1">i</a>代表着以i结尾的递增数组的长度,初始值dp[0][0] = 12.如果a[i] &gt; a[j]（i&gt;j）,说明以a[i]结尾的递增数列的一个子集（有可能不是最长的）可以是[...,a[j],a[i]],所以dp[i][j] = dp[j][j] + 13.如果a[i] &lt;= a[j]（i&gt;j）,说明a[i]结尾的递增数列肯定不包含a[j]，故dp[i][j] = 04.dp[i][i]的值是dp[i]这一列的最大值5.找到所有dp[i]<a href="i=0%EF%BC%8C1%EF%BC%8C2%EF%BC%8C3%EF%BC%8Clen(a)-1">i</a>中的最大值，就是最长的长度</p></blockquote><p>代码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongest</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        n = len(a)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> a[i] &gt; a[j]:</span><br><span class="line">                    dp[i][j] = dp[j][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            tmp = max(dp[i][:])</span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][i] = tmp</span><br><span class="line"></span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="comment">### maxx是dp中最大的值</span></span><br><span class="line">        maxx = max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">        <span class="keyword">return</span> maxx</span><br><span class="line">        self.xunzhao(a, dp, location, [a[location]])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">b = AscentSequence()</span><br><span class="line"></span><br><span class="line">print(b.findLongest([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure></p><hr><h3>2.最长增长子序列中所有增长子序列</h3><p>解题思路：和上面一样找到最大的长度的步骤是一样的，用动态规划，但是需要进行递归查找最大长度递增的子序列，需要注意，结果不止一个。<img src="https://github.com/Buevara/blog_img/raw/master/4.17/4.17-7.jpeg" alt="4.17-7"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xunzhao</span><span class="params">(self, a, dp, end, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dp[end][end] == <span class="number">1</span>:</span><br><span class="line">            self.res.append(tmp[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(end):</span><br><span class="line">            <span class="keyword">if</span> dp[end][i] == dp[end][end] <span class="keyword">and</span> a[i] &lt; a[end]:</span><br><span class="line">                self.xunzhao(a, dp, i, tmp+[a[i]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongest</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        n = len(a)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> a[i] &gt; a[j]:</span><br><span class="line">                    dp[i][j] = dp[j][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            tmp = max(dp[i][:])</span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][i] = tmp</span><br><span class="line"></span><br><span class="line">        <span class="comment">### maxx是dp中最大的值</span></span><br><span class="line">        maxx = max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> dp])</span><br><span class="line">        print(maxx)</span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            <span class="keyword">if</span> dp[i][i] == maxx:</span><br><span class="line">                location = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.xunzhao(a, dp, location, [a[location]])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">b = AscentSequence()</span><br><span class="line"></span><br><span class="line">print(b.findLongest([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--京东机器学习算法岗位</title>
      <link href="/2018/04/16/%E9%9D%A2%E7%BB%8F--%E4%BA%AC%E4%B8%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/04/16/%E9%9D%A2%E7%BB%8F--%E4%BA%AC%E4%B8%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>面经--京东机器学习算法岗位</h2><hr><p>共三面，两轮技术面，一轮hr面。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.python装饰器，迭代器，生成器。</p></li><li><p>3.tensorflow高级操作的包，我回答contrib，他问我这个包的含义是什么,我不会，面试官告诉我是开源贡献者提供的方法。</p></li><li><p>4.机器学习的基础模型都有哪些？ 我答svm和logistic，讲了原理和损失函数的具体含义。</p></li><li><p>5.Inception和ResNet网络结构的特点和差别。</p></li><li><p>6.Hive和Hadoop了解吗？ 回答不了解，尴尬......</p></li><li><p>7.问我为什么没过六级，......  这个问题太难了，我也不知道怎么回答，后来面试官说没事，随口一问，吓死我了。</p></li><li><p>8.他问我有什么想问他的，我问了他所在的部门的具体工作，面试官说主要是做模型建立，给各个深度学习相关的部门提供底层模型支持。</p></li></ul><p>一面结束，二十分钟。（太短了，很不适应）</p><hr><h3>二面</h3><ul><li><p>1.问了我知不知道应聘的部门是做什么的，感不感兴趣。</p></li><li><p>2.迄今为止最印象深刻的项目。</p></li><li><p>3.详细介绍了问了我简历上的三个项目。</p></li><li><p>4.最后给我一些建议，应该完善技术栈，会用并且知道怎么用，需要linux的命令经验，hadoop和spark需要会一些。</p></li></ul><p>二面结束，还是二十分钟，面试官很nice，人很好。</p><hr><h3>hr面</h3><ul><li><p>1.自我介绍。</p></li><li><p>2.为什么从通信工程转到信息安全。</p></li><li><p>3.项目中遇到的最大的困难。</p></li><li><p>4.你能给你们部门带来什么。</p></li></ul><p>hr面结束，还是二十分钟，第一次电话面试比较紧张。</p><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习--Inception和Xception网络</title>
      <link href="/2018/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--Inception%E5%92%8CXception%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/04/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--Inception%E5%92%8CXception%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h2>深度学习--Inception和Xception网络</h2><p>整理了一些Inception和Xception网络的资料：</p><blockquote><p>1.<a href="https://blog.csdn.net/yuanchheneducn/article/details/53045551" target="_blank" rel="noopener">Inception v1到v4演变</a></p><p>2.<a href="https://blog.csdn.net/u010402786/article/details/52433324" target="_blank" rel="noopener">网络模型中Inception的作用与结构全解析</a></p><p>3.<a href="https://www.jianshu.com/p/0583f1ba068c" target="_blank" rel="noopener">卷积神经网络工作原理研究-Inception结构研究</a></p><p>4.<a href="https://blog.csdn.net/xbinworld/article/details/61674836" target="_blank" rel="noopener">卷积神经网络结构变化</a></p><p>5.<a href="https://zhuanlan.zhihu.com/p/33999416" target="_blank" rel="noopener">关于「Inception」和「Xception」的那些事</a></p><p>6.<a href="https://blog.csdn.net/lynnandwei/article/details/53736235" target="_blank" rel="noopener">inception V4 与resnet</a></p><p>7.<a href="https://blog.csdn.net/u014380165/article/details/75142710" target="_blank" rel="noopener">Xception算法详解</a></p><p>8.<a href="https://zhuanlan.zhihu.com/p/29367273" target="_blank" rel="noopener">CNN卷及操作详解</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 网络模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--模型的评价指标</title>
      <link href="/2018/04/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2018/04/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      <content type="html"><![CDATA[<h2>分为回归问题的评价指标和分类问题的评价指标。</h2><blockquote><p>回归问题的评价指标：</p><blockquote><p>1.SSE（误差平方和）</p><p>2.MAE(Mean Absolute Error) 平均绝对误差</p><p>3.MSE(Mean Square Error)<strong>平均平方差/均方误差是回归任务最常用的性能度量</strong>4.MAPE</p><p>5.R-square（决定系数）</p><p>6.Adjusted R-Square (校正决定系数）</p></blockquote></blockquote><blockquote><p>分类问题的评价指标：</p></blockquote><blockquote><blockquote><p>1.accuarcy 正确率</p><p>2.precision,recall,F1-score,F-score,ROC-AUC曲线</p></blockquote></blockquote><hr><h3>回归问题</h3><h4>1.SSE（误差平方和）</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-1.png" alt="4.14-1"></p><h4>2.MAE(Mean Absolute Error) 平均绝对误差</h4><p>$$  MAE=\frac{1}{n}\sum_{n}^{i=1}|Y_predict-Y_actual|  $$</p><h4>3.MSE(Mean Square Error)</h4><p>$$ MSE=\frac{1}{n}\sum_{n}<sup>{i=1}(Y_predict-Y_actual)</sup>{2}  $$</p><h4>4.MAPE</h4><p>全称是Mean Absolute Percentage Error。$$ MAPE=\frac{100}{n}\sum_{n}^{i=1}|\frac{Y_actual-Y_predict}{Y_actual}| $$</p><h4>5.R-square（决定系数）</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-2.png" alt="4.14-2"></p><h4>6.Adjusted R-Square (校正决定系数）</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-3.png" alt="4.14-3"></p><hr><h3>回归问题</h3><h4>1.accuarcy 正确率</h4><p>$$ accuarcy=\frac{N_true}{N_sum} $$$N_true$是分类正确的数量$N_sum$是训练样本的总数量</p><h4>2.precision,recall,F1-score,F-score,ROC-AUC曲线</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-4.png" alt="4.14-4"><img src="https://github.com/Buevara/blog_img/raw/master/shouhuatu/9-8.jpeg" alt="4.14-2018-09-08"><img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-5.png" alt="4.14-5"></p><p>ROC曲线如下图，横轴是负正率，纵轴是真正率。<img src="https://github.com/Buevara/blog_img/raw/master/4.14/4.14-6.png" alt="4.14-6">如何绘制曲线呢？</p><blockquote></blockquote><p>真实标签y=[1,1,0,0,1]分类器预测=[0.5,0.6,0.55,0.4,0.7]我们选择阈值0.1，那么5个样本被分进1类，选择0.3，结果是一样的，选择0.45，那么只有样本4分为0类，其余都是1类，得到类别，我们就能计算真正率和负正率，就可以画图了。</p><blockquote></blockquote><p>理解ROC曲线：</p><p>ROC曲线图中的四个点和一条线。第一个点，(0,1)，即FPR=0, TPR=1，这意味着FN（false negative）=0，并且FP（false positive）=0。这是一个完美的分类器，它将所有的样本都正确分类。第二个点，(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。第三个点，(0,0)，即FPR=TPR=0，即FP（false positive）=TP（true positive）=0，可以发现该分类器预测所有的样本都为负样本（negative）。类似的，第四个点（1,1），分类器实际上预测所有的样本都为正样本。经过以上的分析，我们可以断言，ROC曲线越接近左上角，该分类器的性能越好。</p><p>对于ROC曲线图中的y=x上的点。这条对角线上的点其实表示的是一个采用随机猜测策略的分类器的结果，例如(0.5,0.5)，表示该分类器随机对于一半的样本猜测其为正样本，另外一半的样本为负样本。</p><hr><p>参考相关博客和资料：</p><blockquote></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 评价指标 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--58同城算法岗位、优信二手车数据挖掘岗位</title>
      <link href="/2018/04/12/%E9%9D%A2%E7%BB%8F--58%E5%90%8C%E5%9F%8E%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%E3%80%81%E4%BC%98%E4%BF%A1%E4%BA%8C%E6%89%8B%E8%BD%A6%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/04/12/%E9%9D%A2%E7%BB%8F--58%E5%90%8C%E5%9F%8E%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%E3%80%81%E4%BC%98%E4%BF%A1%E4%BA%8C%E6%89%8B%E8%BD%A6%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>面经--58同城算法岗位、优信二手车数据挖掘岗位</h2><p>58同城两面挂，优信二手车一面结束，所以放在一起整理。</p><hr><h3>58同城算法岗位</h3><h4>一面</h4><ul><li><p>1.自我介绍。</p></li><li><p>2.自己的海量数据处理项目。</p></li><li><p>3.kaggle项目中用到的神经网络的不同，和更优秀的模型的差别。</p></li><li><p>4.机器学习的基础模型中svm的原理，线性不可分时还可以用svm吗？可以，用高斯核函数，无限延伸到无穷维度。</p></li><li><p>5.bagging和boosting的区别？</p></li></ul><p><a href="https://buevara.github.io/2018/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/">答案点击这里</a></p><p>一面结束，四十分钟左右，其中聊项目比较多，没问算法。</p><hr><h4>二面（电话面试）</h4><ul><li><p>1.自我介绍。</p></li><li><p>2.介绍自己最深刻的项目。（京东店铺销量预测大赛）</p></li><li><p>3.XGBOOST和GBDT的不同，为什么XGBOOST复杂度高却比GBDT更快？<a href="https://blog.csdn.net/wolf963/article/details/78508858" target="_blank" rel="noopener">参考答案1</a><a href="https://www.zhihu.com/question/41354392" target="_blank" rel="noopener">参考答案2</a></p></li><li><p>4.python装饰器？</p></li></ul><p>装饰器：拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。<a href="https://blog.csdn.net/u010358168/article/details/77773199" target="_blank" rel="noopener">参考答案</a></p><p>拓展：迭代器：它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。迭代器就是其他语言里的iterator，主要是实现了<code>__iter__</code>，以及和其他语言对应的<code>__next__</code>方法。</p><p>生成器：是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。生成器generator是python特有的，iterator的一个子类，（我理解）主要目的是方便你来实现一个iterator。</p><ul><li>5.为什么树模型不需要归一化特征？</li></ul><p><strong>概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率。像svm、线性回归之类的最优化问题就需要归一化。决策树属于前者。</strong></p><ul><li>6.SVM用于回归模型如何解释？</li></ul><p><a href="http://blog.sina.com.cn/s/blog_62970c250102xfzj.html" target="_blank" rel="noopener">参考答案</a></p><ul><li>7.L1正则化和L2正则化特征，为什么？为什么L1和等值线的交点在坐标轴上的概率最大？<a href="https://www.cnblogs.com/heguanyou/p/7688344.html" target="_blank" rel="noopener">参考答案</a><a href="https://www.zhihu.com/question/23536142" target="_blank" rel="noopener">参考答案</a><a href="https://blog.csdn.net/zhuxiaodong030/article/details/54408786" target="_blank" rel="noopener">参考答案</a><img src="https://github.com/Buevara/blog_img/raw/master/4.16/4.16-3.png" alt="4.16-3"></li><li>8.MySql数据库引擎是什么？</li></ul><p>二面结束，三十分钟左右，其中聊项目比较多，基础知识问的都只能说出一些，再往深我没想过，面试官说希望对模型有更深的理解。</p><hr><h3>优信二手车数据挖掘岗位</h3><h4>一面</h4><ul><li><p>1.自我介绍。</p></li><li><p>2.自己JD店铺预测项目如何做的，用了什么模型？SVM,XGBOOST,GBDT...</p></li><li><p>3.SVM有哪些超参数？惩罚系数C和核函数选择和核函数的$ \sigma $。</p></li></ul><blockquote><p>使用SVM时，有两个点要注意：若使用核函数，一定要对Feature做Feature Scaling(Normalization)若训练集m太小，但Feature数量n很大，则训练数据不足以拟合复杂的非线性模型，这种情况下只能用linear-kernel（就是fi=xi）不能用高斯核</p></blockquote><p>来自于 Andrew NG. machine learning class at coursera</p><ul><li>4.logistic回归的超参数？只有一个：学习率</li><li>5.针对于回归问题的评价指标？当时没答上来，应该是mse，mae，决定系数等等。</li><li>5.AUC和ROC怎么求？概念不是很清晰，没推导出来</li><li>6.bagging和boosting的区别？</li><li>7.bagging和boosting分别对模型的偏差和方差有着怎样的影响？简单来说，就是bagging方差降低了，偏差高。boosting是对偏差进行拟合，降低了偏差，方差会随着训练增大。</li></ul><p><img src="https://github.com/Buevara/blog_img/raw/master/4.16/4.16-1.png" alt="4.16-1"></p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.16/4.16-2.png" alt="4.16-2">图片和结论来自于<a href="https://blog.csdn.net/shenxiaoming77/article/details/53894973" target="_blank" rel="noopener">Michael_Shentu的博客</a></p><ul><li>时间复杂度和空间复杂度的含义？</li><li>算法题：</li><li>1.求一个字符串的所有子集？ 简单递归思想</li><li>2.二分查找</li></ul><p>一面结束，五十分钟，答的一般，有两个问题不会。一面结束让我等一下，进行二面，过了一会说二面不在，到时候再约面试，我说ok。晚上hr小姐姐给我打电话，本来以为要约二面，结果和我说不用了，等下个月通知，一脸懵逼。</p><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--最大似然估计（MLE）和最大后验概率（MAP）</title>
      <link href="/2018/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%88MLE%EF%BC%89%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%EF%BC%88MAP%EF%BC%89/"/>
      <url>/2018/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%88MLE%EF%BC%89%E5%92%8C%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%EF%BC%88MAP%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2>最大似然估计（MLE）和最大后验概率（MAP）</h2><hr><h3>最大似然估计 MLE</h3><p>给定一堆数据，加入我们知道他是从某一分部中随机取出来的。可是我们并不知道这个分布具体的参，即“模型已定，参数未知”。例如，我们知道这个分布是正态分布，但是不知道均值和方差；或者是二项分布，但是不知道均值。最大似然估计（MLE，Maximum Likelihood Estimation）就可以用来估计模型的参数。MLE的目标是找出一组参数，使得模型产生出观测数据的概率最大：$ \arg max _{ \mu}(p(X; \mu)) $</p><p>其中$ p(X; \mu) $ 就是似然函数，表示在参数$ \mu $ 下出现观测数据的概率。我们假设每个观测数据是独立的，那么有<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-1.png" alt="4.9-1"></p><p>为了寻求方便，一般对目标取$ log $。所以最优化似然函数等于最优化对数似然函数：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-2.png" alt="4.9-2">举一个抛硬币的简单例子。 现在有一个正反面不是很匀称的硬币，如果正面朝上记为正，方面朝上记为反，抛10次的结果如下：</p><p>正正正反反反正反正反</p><p>很显然这个概率是0.5。现在我们用MLE的思想去求解它。我们知道每次抛硬币都是一次二项分布，设正面朝上的概率是$ \mu $，那么似然函数为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-3.png" alt="4.9-3">x=1表示正面朝上，x=0表示方面朝上。那么有：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-4.png" alt="4.9-4">求导：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-5.png" alt="4.9-5">令导数为0，很容易得到：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-6.png" alt="4.9-6">也就是0.5。</p><hr><h3>最大后验概率  MAP</h3><p>以上求MLE   求得是找出一组能够使似然函数最大的参数，即$ \arg max <em>{ \mu}(p(X; \mu)) $ 。现在问题稍微复杂一点，假如这个参数$ \mu $ 有一个先验概率呢？比如说，在上面抛硬币的例子，假如我们的经验告诉我们，硬币一般都是均匀的，也就是$ \mu $=0.5的可能性最大，$ \mu $=0.2的可能性比较小，那么参数如何估计呢？这就是MAP要考虑的问题。MAP优化的是一个后验概率，即给定了观测值后是的$ \mu $最大的：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-7.png" alt="4.9-7">把上式根据贝叶斯公式展开：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-8.png" alt="4.9-8">我们可以看出第一项$ p(X; \mu) $ 就是似然函数，第二项$ p(\mu) $就是先验知识。取$ log $之后就是：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-9.png" alt="4.9-9">回到刚才的抛硬币的例子，假设参数$ \mu $有一个先验估计，他服从$ Beta $分布，即：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-10.png" alt="4.9-10">而每次抛硬币仍然服从二项分布：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-11.png" alt="4.9-11">那么目标函数的导数是：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-12.png" alt="4.9-12">求导的第一项已经在MLE中给出了，第二项为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-13.png" alt="4.9-13">令导数为0，求解为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-14.png" alt="4.9-14">其中，$ n</em>{H} $表示正面朝上的次数。这里看以看出，MLE与MAP的不同之处在于，MAP的结果多了一些先验分布的参数。</p><hr><h3>补充知识： Beta分布</h3><p>Beat分布是一种常见的先验分布，它形状由两个参数控制，定义域为[0,1]<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-15.png" alt="4.9-15"></p><p>Beta分布的最大值是x等于$ \frac{\alpha -1}{\alpha +\beta -2} $的时候：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-16.png" alt="4.9-16">所以在抛硬币中，如果先验知识是说硬币是匀称的，那么就让$ \alpha = \beta  $。但是很显然即使它们相等，它两的值也对最终结果很有影响。它两的值越大，表示偏离匀称的可能性越小：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-17.png" alt="4.9-17"></p><hr><p>文章转自 <a href="http://www.cnblogs.com/sylvanas2012/p/5058065.html" target="_blank" rel="noopener">Leavingseason的博客</a></p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--模型融合方法</title>
      <link href="/2018/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3>Ensemble Learning--模型融合</h3><p>含义：通过对多个单模型融合以提升整体性能。</p><blockquote><p>1.Voting</p><p>2.Averaging</p><p>3.Ranking</p><p>4.Bagging</p><p>5.Boosting</p><p>6.Bagging和Boosting的区别</p><p>7.Stacking</p><p>8.Blending</p><p>9.Stacking和Blending的区别</p></blockquote><h4>模型的融合条件</h4><ul><li>[x]  Base Model 之间的相关性要尽可能的小。这就是为什么非 Tree-based Model 往往表现不是最好但还是要将它们包括在 Ensemble 里面的原因。Ensemble 的 Diversity 越大，最终 Model 的 Bias 就越低。</li><li>[x]  Base Model 之间的性能表现不能差距太大。这其实是一个 Trade-off，在实际中很有可能表现相近的 Model 只有寥寥几个而且它们之间相关性还不低。但是实践告诉我们即使在这种情况下 Ensemble 还是能大幅提高成绩。</li></ul><hr><h4>1.Voting</h4><blockquote><p>投票即为，投票多者为最终的结果。用于分类问题：多个模型投票（当然可以设置权重）。最终投票数最多的类为最终被预测的类。</p></blockquote><hr><h4>2.Averaging</h4><blockquote><p>Averaging即所有预测器的结果平均。</p></blockquote><ul><li>[ ] 回归问题，直接取平均值作为最终的预测值。（也可以使用加权平均）</li><li>[ ] 分类问题，直接将模型的预测概率做平均。（or 加权）</li></ul><p>加权平均，其公式如下：<img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-2.png" alt="4.11-2"></p><p>其中n表示模型的个数， $Weighti$表示该模型权重，$Pi$表示模型i的预测概率值。</p><hr><h4>3.Ranking</h4><blockquote><p>Rank的思想其实和Averaging一致，但Rank是把排名做平均，对于例如一些评价指标有效，如：AUC指标。</p></blockquote><p>具体公式如下：</p><p>加权平均，其公式如下：</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-3.png" alt="4.11-3"></p><p>其中n表示模型的个数， $Weighti$表示该模型权重，所有权重相同表示平均融合。$Ranki$表示样本在第i个模型中的升序排名。它可以较快的利用排名融合多个模型之间的差异，而不需要加权融合概率。</p><hr><h4>4.Bagging</h4><blockquote><p>1.同一个学习算法在来自同一分布的多个不同的训练数据集上训练得到的模型偏差可能较大，即模型的方差（variance）较大，为了解决这个问题，可以综合多个模型的输出结果，对于回归问题可以取平均值，对于分类问题可以采取多数投票的方法。这就是Bagging的核心思想。2.Bagging(Bootstrap Aggregation)是常用的统计学习方法，其综合的基本学习器可以是各种弱学习器。3.使用训练数据的不同随机子集来训练每个 Base Model，最后每个 Base Model 权重相同，分类问题进行投票，回归问题平均。经典算法：随机森林</p></blockquote><p>注意： <strong>有放回抽样</strong> （可能抽到重复的样本）</p><p>Bagging是将弱分类器组装成强分类器的方法。具体步骤：A）从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</p><p>B）每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</p><p>C）对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</p><p>如图所示：</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-4.png" alt="4.11-4"></p><p>要想综合N个弱分类器（决策树）的结果，我们需要采样N个训练数据集，在实际应用中获取N个训练数据集往往不现实，BootStrap 采样提供了一种有效的解决方法。采用这样的方式解决了获取N个服从同一分布的原始数据集不现实的问题，而且在可接受程度上，可以认为Bootstrap 采样方式不影响到模型的准确性（以方差来衡量），即可以等价于使用N个不同的原始数据集。</p><blockquote><p>Bagging较单棵决策树来说，降低了<em>方差</em>，但由于将多棵决策树的结果进行了平均，这损失了模型的可解释性。</p></blockquote><hr><h4>5.boosting</h4><p>Boosting是一种迭代的方法，每一次训练会更关心上一次被分错的样本。</p><blockquote><p>核心问题：1）在每一轮如何改变训练数据的权值或概率分布？</p></blockquote><blockquote><p>通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</p></blockquote><blockquote><p>2）通过什么方式来组合弱分类器？</p></blockquote><blockquote><p>通过加法模型将弱分类器进行线性组合</p></blockquote><p>经典算法：</p><p>AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</p><p>提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。</p><hr><h4>6.Bagging和Boosting的区别</h4><p>Bagging和Boosting的区别：</p><p>1）样本选择上：</p><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><p>2）样例权重：</p><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><p>3）预测函数：</p><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><p>4）并行计算：</p><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><blockquote><p>这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。</p></blockquote><blockquote><p>下面是将决策树与这些算法框架进行结合所得到的新的算法：</p></blockquote><blockquote><p>1）Bagging + 决策树 = 随机森林</p></blockquote><blockquote><p>2）AdaBoost + 决策树 = 提升树</p></blockquote><blockquote><p>3）Gradient Boosting + 决策树 = GBDT</p></blockquote><hr><h4>7.Stacking</h4><p><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-5.jpg" alt="4.11-5">图片来自于<a href="https://zhuanlan.zhihu.com/p/26890738" target="_blank" rel="noopener">Leon的知乎专栏</a>个人认为很想深度学习模型中的xception网络，这里不同的模型相当于xception中不同尺寸的卷积，进行不同特征的提取。</p><p>我们在这里只考虑两层的stacking，多层同理。</p><p>假设第一层的用到3个模型model1，model2，model3，第二层一个模型model4。步骤：</p><ol><li>首先先将训练集分成用K fold</li><li>用model对K-1折进行训练，剩下1折进行预测，一共可以的到K个（训练数据总数n/k）个结果，我们将其按照顺序排好，第1个n/k对应K折中的1折。reshape成为一个n*1的预测结果（我们可以把他考虑成为特征向量）</li><li>针对于预测集，K折交叉验证的每一次，都要对预测集进行一次预测，一共可以得到K*（预测集总数m），我们将其取平均，得到一个1*m的预测label（也可以看做是预测集的特征向量）</li><li>对于第一层的每个模型model1、model2、model3，我们都进行步骤1、2、3的操作，我们最终得到了训练集的特征向量是3*n（3是第一层的模型1数），得到预测集的特征向量是3*m。</li><li>对于第二层，我们用第一层得到的3*n作为特征用model4进行训练，模型训练结束后对3*m进行预测，得到最终的结果。</li></ol><p>最顶层的模型一般是LR或者线性模型。</p><hr><h4>8.Blending</h4><blockquote><p>Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集，例如说10%的训练数据，第二阶段的stacker模型就基于第一阶段模型对这10%训练数据的预测值进行拟合。说白了，就是把Stacking流程中的K-Fold CV 改成 HoldOut CV。</p></blockquote><p>举例：1.将数据划分成train,test，然后将train划分成不相交的两部分train_1,train_2</p><p>2.使用不同的模型对train_1训练，对train_2和test预测，生成两个1维向量，有多少模型就生成多少维向量</p><p>3.第二层使用前面模型对train_2生成的向量和label作为新的训练集，使用LR或者其他模型训练一个新的模型来预测test生成的向量</p><hr><h4>9.Stacking和Blending的区别</h4><ol><li>stacking由于加入了K-fold，更加复杂；blending不用K-fold，所以更加简单</li><li>stacking因为使用K-fold，所以训练集的数据分布和原数据集的不一样了，会引入估计偏差；而blending不会。</li><li>blending用的数据会过少，多层之后，有可能会过拟合；而stacking不会出现。</li></ol><p>两种方法都可以用下图来表示：<img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-6.png" alt="4.11-6"></p><hr><p>参考相关博客和资料：</p><blockquote><p>1: https://blog.csdn.net/shine19930820/article/details/75209021#11-voting</p><p>2: https://zhuanlan.zhihu.com/p/26890738</p><p>3: https://www.cnblogs.com/liuwu265/p/4690486.html</p><p>4: https://blog.csdn.net/sinat_29819401/article/details/71191219</p><p>5: https://blog.csdn.net/bryan__/article/details/51229032</p><p>6: https://blog.csdn.net/foolsnowman/article/details/51726007</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 模型融合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--瓜子二手车数据分析岗位</title>
      <link href="/2018/04/01/%E9%9D%A2%E7%BB%8F--%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/04/01/%E9%9D%A2%E7%BB%8F--%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>面经--瓜子二手车数据分析岗位</h2><hr><p>面试约的上午九点半，去了直接面试，估计去的太早了。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.介绍一下机器学习模型都有哪些，判别模型和生成模型区别，具体有哪些。</p></li><li><p>3.推导logistic的损失函数。</p></li><li><p>4.什么是过拟合，过拟合如何解决。</p></li><li><p>5.什么是gbdt，gbdt如何确定第一棵树，没答出来，她换了个问法，说给你两个特征x，x1是连续的，x2是非连续的，和对应的label，具体的构建gbdt的方法。</p></li><li><p>6.描述kmeans算法，难度加深，给定一个每个点和其他点的距离而不是坐标，该如何聚类。</p></li><li><p>7.最后一道算法题：不用内置函数求sqrt，给定x和 $\Sigma$, 其中$ \Sigma $是误差项。应该用二分查找，但是最后没写出来。</p></li></ul><p>一面结束，三十分钟左右。</p><hr><h3>二面</h3><ul><li><p>1.自我介绍。</p></li><li><p>2.什么是极大似然估计，如何推导。</p></li><li><p>3.什么是最大后验概率，如何推导。</p></li><li><p>4.描述一下朴素贝叶斯。</p></li><li><p>5.算法题：旋转数组中找到x。leetcode33题</p></li><li><p>6.1求概率：得分问题，赢一局得一分，输一局，不扣分，赢和输概率为p和q，n局得到m分的概率是。</p></li><li><p>6.2前面的问题难度加大，输一局扣一分，求n局得到m分的概率是。</p></li><li><p>6.3难度再提升，扣为0分不降分，n局得到m分的概率是。当时没做出来（应该用动态规划）</p></li><li><p>7.1用一枚硬币（1/2的概率）求出一个1/3的概率。</p></li><li><p>7.2用一枚硬币（1/2的概率）求出一个1/3的概率。</p></li><li><p>7.3用不均匀一枚硬币（概率不为1/2）求出一个1/3的概率。</p></li></ul><p>二面面试官问我有什么要问的，我问了一下他所在的部门是做什么的，都有什么方向，他说在做分类推荐。二面结束，共四十分钟左右，面试官很和善，但是他出的问题都不是我自己独立解答的，80%都需要他的一些指引，认识到了自己的不足，继续努力。</p><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--L1正则化项和L2正则化项理解</title>
      <link href="/2018/04/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--L1%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E5%92%8CL2%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E7%90%86%E8%A7%A3/"/>
      <url>/2018/04/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--L1%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E5%92%8CL2%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2>L1正则化项和L2正则化项的理解</h2><hr><p>概念：</p><blockquote><p>L1正则化是指权值向量w中各个元素的绝对值之和，通常表示为$ ||W||_{1} $</p></blockquote><blockquote><p>L2正则化是指权值向量w中各个元素的平方和然后再求平方根（可以看到Ridge回归的L2正则化项有平方符号），通常表示为$ ||W||_{2} $</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/8.30/l1%E5%92%8Cl2%E5%88%86%E5%B8%83.png" alt="8.30"></p><p>先抛出个结论：</p><blockquote><p>L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于特征选择,L1范数.L2范数是指向量各元素的平方和然后求平方根。我们让L2范数的正则项$ ||W||_{2} $最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，大比起1范数，更常用L2范数。通过L2范数，我们可以实现了对模型空间的限制，从而在一定程度上避免了过拟合；一定程度上，L1也可以防止过拟合</p></blockquote><hr><h3>L1正则化</h3><p>为什么L1正则化可以产生稀疏模型（L1是怎么让系数等于零的），以及为什么L2正则化可以防止过拟合？假设有如下带L1正则化的损失函数：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-18.png" alt="4.9-18"></p><p>其中$ J0 $是原始的损失函数，加号后面的一项是$ L1 $正则化项，$ α $是正则化系数。注意到$ L1 $正则化是权值的绝对值之和，$J$是带有绝对值符号的函数，因此$J$是不完全可微的。机器学习的任务就是要通过一些方法（比如梯度下降）求出损失函数的最小值。当我们在原始损失函数$J0$后添加$L1$正则化项时，相当于对$J0$做了一个约束。令$L=α∑w|w|$，则$J=J0+L$，此时我们的任务变成在$L$约束下求出$J0$取最小值的解。考虑二维的情况，即只有两个权值$w1$和$w2$，此时$L=|w1|+|w2|$对于梯度下降法，求解$J0$的过程可以画出等值线，同时$L1$正则化的函数$L$也可以在$w1w2$的二维平面上画出来。如下图<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-19.png" alt="4.9-19"></p><p>图中等值线是$J0$的等值线，黑色方形是$L$函数的图形。在图中，当$J0$等值线与$L$图形首次相交的地方就是最优解。上图中$J0$与$L$在$L$的一个顶点处相交，这个顶点就是最优解。注意到这个顶点的值是$(w1,w2)=(0,w)$。可以直观想象，因为$L$函数有很多『突出的角』（二维情况下四个，多维情况下更多），$J0$与这些角接触的机率会远大于与$L$其它部位接触的机率，而在这些角上，会有很多权值等于$0$，这就是为什么$L1$正则化可以产生稀疏模型，进而可以用于特征选择。</p><p>而正则化前面的系数$α$，可以控制L图形的大小。$α$越小，$L$的图形越大（上图中的黑色方框）；$α$越大，$L$的图形就越小，可以小到黑色方框只超出原点范围一点点，这是最优点的值$(w1,w2)=(0,w)$中的$w$可以取到很小的值。</p><hr><h3>L2正则化</h3><p>假设有如下带L2正则化的损失函数：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-20.png" alt="4.9-20">同样可以画出他们在二维平面上的图形，如下：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-21.png" alt="4.9-21">二维平面下L2正则化的函数图形是个圆，与方形相比，被磨去了棱角。因此J0与L相交时使得w1或w2等于零的机率小了许多，这就是为什么L2正则化不具有稀疏性的原因。</p><hr><h3>L2正则化和过拟合</h3><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。</p><blockquote><p>那为什么L2正则化可以获得值很小的参数？</p></blockquote><p>以线性回归中的梯度下降法为例。假设要求的参数为$θ$，$hθ(x)$是我们的假设函数，那么线性回归的代价函数如下：以线性回归中的梯度下降法为例。假设要求的参数为$θ，hθ(x)$是我们的假设函数，那么线性回归的代价函数如下：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-22.png" alt="4.9-22">那么在梯度下降法中，最终用于迭代计算参数θ的迭代式为：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-23.png" alt="4.9-23"><img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-24.png" alt="4.9-24">其中$α$是learning rate. 上式是没有添加L2正则化项的迭代公式，如果在原始代价函数之后添加L2正则化，则迭代公式会变成下面的样子：<img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-25.png" alt="4.9-25">其中$λ$就是正则化参数。从上式可以看到，与未添加$L2$正则化的迭代公式相比，每一次迭代，$θj$都要先乘以一个小于1的因子，从而使得$θj$不断减小，因此总得来看，$θ$是不断减小的。最开始也提到$L1$正则化一定程度上也可以防止过拟合。之前做了解释，当$L1$的正则化系数很小时，得到的最优解会很小，可以达到和$L2$正则化类似的效果。</p><hr><h3>正则化参数的选择</h3><blockquote><p>通常越大的$λ$可以让代价函数在参数为$0$时取到最小值。</p></blockquote><p><img src="https://github.com/Buevara/blog_img/raw/master/4.9/MLE4.9-26.png" alt="4.9-26"></p><p>分别取$λ=0.5$和$λ=2$，可以看到越大的$λ$越容易使$F(x)$在$x=0$时取到最小值。</p><blockquote><p>$λ$越大，$θj$衰减得越快。另一个理解可以参考上图，$λ$越大，$L2$圆的半径越小，最后求得代价函数最值时各参数也会变得很小。</p></blockquote><h2>除了：L1和L2 regularization外，正则化常用的方法还有：数据集扩增、dropout</h2><p>文章转自 <a href="https://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="noopener">阿拉丁吃米粉的博客</a></p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 正则化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋招面经--小米机器学习岗位</title>
      <link href="/2018/03/31/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F--%E5%B0%8F%E7%B1%B3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/03/31/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F--%E5%B0%8F%E7%B1%B3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>秋招面经--小米机器学习算法岗位</h2><hr><p>说来也巧，春招第一家是小米，秋招小米是第二家，第一家是搜狗(已挂)。面试约的下午两点，准时开始面试。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.项目中用到的模型融合为什么不能无限的加全连接层？</p></li><li><p>我答全连接层越多会过拟合，面试官好像觉得我说的不对，他说是防止梯度爆炸或者梯度消失，存在疑惑？参考文献：https://blog.csdn.net/guoyunfei20/article/details/78283043</p></li><li><p>3.如何进行迁移训练，举例如何用猫狗分类的模型迁移到人脸项目中？</p></li><li><p>完全懵逼，我说直接取卷积层进行使用，他说还有别的方法，这样太粗暴了。可以用freeze的方式，一次训练某几层，freeze某几层。</p></li><li><p>回来查资料才发现应该是让我解答迁移学习和fine-tune：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">迁移学习：</span><br><span class="line">迁移学习，是一种思想吧，并不是一种特定的算法或者模型，目的是将已学习到的知识应用到其他领域，提高在目标领域上的性能，比如说一个通用的语音模型迁移到某个人的语音识别，一个ImageNet上的图片分类问题迁移到医疗疾病识别上。</span><br><span class="line"></span><br><span class="line">而实现迁移学习最主要的方法则是finetune, 需要说明一点的是，很多人会把迁移学习和finetune混淆，其实两者是有区别的，finetune只是实现迁移学习的一种方法而已， 而finetune本身既可以用于迁移学习，也可以用于自身原有的训练学习，比如在已经初步训练好的一个模型基础上，用同样的数据再来训练微调，这也是finetune.而且，在深度学习领域，因为模型都比较复杂，train from scratch 一般需要耗费很长的时间，少则1-2周，多则1-2个月也是有可能的，如果没有GPU,那就不知道哪个猴年马月才能训练好，所以多数都是用finetune来训练的。</span><br><span class="line">    那么finetune该怎么使用呢？？一般可有如下几种情形：</span><br><span class="line"></span><br><span class="line">1. 自己的数据集比较小，和原先的数据集比较类似。首先，两者是比较类似的，所以可做浅层次的finetune，即只改最后几层，一般是只训练最后的分类层（数据集太少如果训练很多层的话，容易过拟合），而前面层的权重啥的不做改动，直接用来生成CNN feature。同时，因为数据集比较小，最好训练线性分类器。</span><br><span class="line"></span><br><span class="line">2. 自己的数据集比较大，和原先的数据集比价类似。由于数据集比较，所以可以训练整个网络，即finetune through the full network, 这样既不会过拟合也能取得不错的效果。那么什么是finetune through the full network呢？用原有的模型（pre-trained model）的参数来初始化，然后再结合当前的数据集继续训练。</span><br><span class="line"></span><br><span class="line">3. 自己的数据集比较小，而且和原先的数据集很不相同。如前所述，小数据集最好训练线性分类器，而同时两者又不相同，那么就不能只训练最后几层了，可以选取从中间或者更早的某一层开始训练，也不建议特别往前，因为数据集比较小太往前开始训练容易过拟合。</span><br><span class="line"></span><br><span class="line">4. 数据集比较大，而且和原先的数据集很不相同。这种情形我们可以train from sratch，就是完全从随机参数开始训练，不用迁移学习，不用以前别的模型的参数。其实，而且实际中，往往也会用迁移学习，用先前的模型的参数来初始化，然后再训练，即finetune through the full network。</span><br><span class="line"></span><br><span class="line">参考答案：</span><br><span class="line">https://www.zhihu.com/question/49534423</span><br><span class="line">https://blog.csdn.net/u010402786/article/details/70141261</span><br></pre></td></tr></table></figure></p></li><li><p>3.过拟合的主要原因？如何解决？为什么用L1和L2，L1和L2的原理，为什么有时同时用呢？</p></li><li><p>同时用的原因就是既可以筛除特性，又可以降低特征权值w，当时没打上来。唉！参考文献：https://www.cnblogs.com/yxwkf/p/5268577.html</p></li><li><p>4.xgboost的原理？</p></li><li><p>中间问我GBDT为什么要用梯度进行下降方向作为更新。他看我写公式不怎么熟练，就解释了霍夫曼编码和二叉树的联系，为什么xgboost要用泰勒展开式。我听得目瞪口呆，他说没事，互相讨论是进步的一种方式。</p></li><li><p>5.不同的损失函数有什么差别呢？为什么分类用交叉熵，用mse可以吗，那为什么不用mse或者hingeloss？？？</p></li><li><p>这个问题真的不会，他也没给我解释。</p></li><li><p>6.结束之前让我问他问题，我就好奇的问了他是不是搞理论的，他说是博士研究编码，之前在外企工作。</p></li></ul><p>一面结束，四十分钟左右。</p><hr><h3>二面</h3><p>面试官应该是工程专家（从发型就能看出来）：</p><ul><li>1.讲一下京东实习的内容，blabla讲了一堆，对我说不关心架构，只关心如何运行分布式，然后气氛突然很尴尬。</li><li>2.问了我的京东算法大赛，讲了一下思路，问了一下第一名的解题思路，差别有多大。</li><li>3.xgboost和GBDT的差别？</li><li>4.如何把算法封装，外部调用？一脸懵逼中。。。</li><li>5.算法题，普通数组中的topK大的数？</li><li>就是快速排序，问了我时间复杂度，我说nlogn，他说这道题的算法是吗？我说nlogk，让我继续写，写了不到十分钟，结束。</li><li>6.算法题，一个字符串的全排列？</li><li>基础递归，很简单</li><li>7.最后问我你的技术栈还有什么，让我想想还有什么优势，想了半天，啥也没说，最后临走问我期望工作地点，选北京还是武汉？我说都可以。</li></ul><p>二面结束，一个小时左右。总体面试还是很慌，毕竟才第二次。</p><hr><p>PS：搜狗面试全程项目，没什么营养，只有一道算法题有价值：</p><ul><li>10w条数据的语料库，每条2-3个词，给一句话‘我今天来搜狗面试’,从后向前分词，如‘我今天来搜狗面/试’，遇到语料库的词，提取，没有继续向前，若只剩一个字，直接提取，请写出程序？</li><li>用了最基础匹配算法，觉得肯定和10w有关，结果讲完就没有然后了。 之后就gg了。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面经--小米机器学习岗位</title>
      <link href="/2018/03/31/%E9%9D%A2%E7%BB%8F--%E5%B0%8F%E7%B1%B3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B2%97%E4%BD%8D/"/>
      <url>/2018/03/31/%E9%9D%A2%E7%BB%8F--%E5%B0%8F%E7%B1%B3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B2%97%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2>面经--小米机器学习算法岗位</h2><hr><p>感谢两位校友@<a href="https://marcovaldong.github.io/" target="_blank" rel="noopener">Marcovaldo</a>和@<a href="http://coconlp.top/" target="_blank" rel="noopener">KillersDeath</a>提供的面经。面试约的下午三点，第一次面试，心里有点紧张。</p><hr><h3>一面</h3><ul><li><p>1.自我介绍.</p></li><li><p>2.介绍一下机器学习模型都有哪些。</p></li><li><p>3.深度学习网络的网络特性和不同，主要说了Alexnet和ResNet的主要特征。说的时候问到是不是用layers直接写，我说最早也用conv和pooling，relu写过浅层的网络。</p></li><li><p>4.梯度爆炸和梯度消失，梯度爆炸当时没理解清，没回答的很明白。这个解释很好：<a href="https://www.zhihu.com/question/66027838/" target="_blank" rel="noopener">梯度爆炸</a></p></li><li><p>5.项目上对如何找特征，用了什么模型和技巧，损失函数用的什么。我说用的gbdt，xgboost和SVM，他问我gbdt和SVM哪个对特征不需要处理（gbdt）， xgboost和gbdt的区别，回答速度快。问为什么xgboost速度快，回答用了二阶导数，问xgboost可以自定义损失函数，那你比赛利用的损失函数是什么，你对你的损失函数求一下二阶导，这坑挖的，算了半天没算出来。</p></li><li><p>6.L1、L2正则化的区别，为什么会产生稀疏性，为什么会降低特征权重。</p></li><li><p>7.给1张5*5*3的图片，3*3*64的卷积，用到了多少参数。（应该是想问我卷积层参数共享）</p></li><li><p>8.最后一道算法题：排序数组中给定某个重复出现数字第一次出现的下标。 剑指offer原题，算了半天用了两次二分查找，才写出来，面试官估计不咋满意。</p></li></ul><p>一面结束，四十分钟左右。</p><hr><h3>二面</h3><p>面试官应该是C++大神，想问我指针和数据流方面的题，但我都不会。于是问了三道算法题和一些小问题：</p><ul><li><p>1.一个n*m的矩阵，所有数无顺序，求第k大的数。想用快排，面试官说可以，但是不是最好的。最后没想出来，结束后和同学讨论应该是堆排序加上mapreduce。</p></li><li><p>2.反转链表。剑指offer原题。</p></li><li><p>3.中间问了一下函数的传参问题。</p></li><li><p>4.问了堆排序。</p></li><li><p>5.旋转数组找k。leetcode33题。</p></li></ul><p>二面结束，三十分钟左右，写算法特别慢，估计挂了。</p><hr>]]></content>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--数学问题</title>
      <link href="/2018/03/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3>记录一下算法中出现的数学问题。</h3><blockquote><p>1.计算最小公倍数2.计算平方根3.不用加减乘除运算符做加法</p></blockquote><hr><h3>1.计算最小公倍数</h3><blockquote><p>题目要求：给定一个数n，求n之前（包括n）所有正整数的值得最小公倍数。</p></blockquote><p>解题思路：判断小于n的数里有多少个质数，质数由z1，z2，z3...zm组成，求得对于每一个质数z的$ int(log_{z}^{n}) $，</p><p>例如： 5小于等于5的质数由[2,3,5]答案是：2<sup>{int(log_{2}</sup>{5})}* 3<sup>{int(log_{3}</sup>{5})}* 5<sup>{int(log_{3}</sup>{5})} = 60</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    prime = [<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        sign = <span class="keyword">True</span></span><br><span class="line">        m = int(math.sqrt(i))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>:</span><br><span class="line">                sign = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sign:</span><br><span class="line">            prime.append(i)</span><br><span class="line">    <span class="keyword">return</span> prime</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logK</span><span class="params">(k, n)</span>:</span></span><br><span class="line">    res = k</span><br><span class="line">    <span class="keyword">while</span> res &lt; n:</span><br><span class="line">        res *= k</span><br><span class="line">    <span class="keyword">if</span> res&gt; n:</span><br><span class="line">        <span class="keyword">return</span> int(res/k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tosum</span><span class="params">(l, n)</span>:</span></span><br><span class="line">    summ = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        summ *= logK(i, n)</span><br><span class="line">    <span class="keyword">return</span> summ</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(n)</span>:</span></span><br><span class="line">    l = isPrime(n)</span><br><span class="line">    <span class="keyword">return</span> tosum(l, n)</span><br><span class="line">    </span><br><span class="line">print(solve(<span class="number">10</span>))  <span class="comment">##例子</span></span><br></pre></td></tr></table></figure></p><hr><h3>2.求平方根</h3><blockquote><p>题目要求：给定一个数n和误差参数 $ \varepsilon  $，求数n的平方根，并且误差不能大于 $ \varepsilon  $。</p></blockquote><p>解题思路：二分查找的经典题。每次start和end的中点mid的平方+e和目标值n做比较。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span><span class="params">(s, start, end, e)</span>:</span></span><br><span class="line">    mid = (start+end)/<span class="number">2.0</span></span><br><span class="line">    <span class="keyword">if</span> mid**<span class="number">2</span>+e &gt;=s <span class="keyword">and</span> s&gt;=mid**<span class="number">2</span>-e:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> mid**<span class="number">2</span>+e &gt;s:</span><br><span class="line">            <span class="keyword">return</span> binary(s, start, mid,e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary(s, mid, end, e)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tosqrt</span><span class="params">(n, e)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = n</span><br><span class="line">    <span class="keyword">return</span> binary(n, start, end, e)</span><br><span class="line">    </span><br><span class="line">print(tosqrt(<span class="number">10</span>, <span class="number">0.5</span>)) <span class="comment">##测试</span></span><br></pre></td></tr></table></figure></p><hr><h3>3. 不用加减乘除运算符做加法(<a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">剑指offer</a>)</h3><blockquote><p>设计一个算法，不使用加减乘数运算符号实现加法运算。</p></blockquote><p>解题思路：</p><p>位运算：</p><p>第一步：计算两个数的对应位，但是不计算进步，主要有四种情况，0+0=0，0+1=1，1+0=1，1+1=0，可以看出这正好对应异或操作。</p><p>第二步：计算两个数的进位，只有在1+1的情况下才会有进位，这正好对应与运算，计算完之后，每位上的数正好是后一位的进位，这时把结果左移一位即可。</p><p>第三步：把第一步的结果和第二步的结果相加，查看是否有进位，如果有进位重复第一步和第二步，直到没有进位为止。注意：python如果数值大于32位，自动转化为long，我们不能让数值转换为long，做了一些限制。更为详细请点击：<a href="https://www.v2ex.com/t/195894" target="_blank" rel="noopener">参考python的int整型转化long</a><img src="https://github.com/Buevara/blog_img/raw/master/4.11/4.11-1.png" alt="4.11-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line"><span class="comment">## python int最大值</span></span><br><span class="line">        MAX = <span class="number">0x7FFFFFFF</span></span><br><span class="line"><span class="comment">## python int最小值</span></span><br><span class="line">        MIN = <span class="number">0x80000000</span></span><br><span class="line"><span class="comment">## 防止转化成long的标志数</span></span><br><span class="line">        mask = <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; mask <span class="comment">##转换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= MAX <span class="keyword">else</span> ~(a ^ mask) <span class="comment">##防止越界</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--回文串问题</title>
      <link href="/2018/03/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3>什么是回文palindrome？</h3><blockquote><p>回文指的是正读和反读都一样的字符串，如aba，abba等</p></blockquote><hr><h3>字符子串和字符子序列的区别?</h3><blockquote><p>字符字串指的是字符串中连续的n个字符；如palindrome中，pa，alind，drome等都属于它的字串而字符子序列指的是字符串中不一定连续但先后顺序一致的n个字符；如palindrome中，plind，lime属于它的子序列，而mod，rope则不是，因为它们与字符串的字符顺序不一致。</p></blockquote><hr><h3>最长回文子序列</h3><blockquote><p>题目要求：给定字符串，求它的最长回文子序列长度。回文子序列反转字符顺序后仍然与原序列相同。例如字符串abcdfcba中，最长回文子序列长度为7，abcdcba或abcfcba。</p></blockquote><p>解题思路：动态规划头尾字符串分别为start和end</p><p>如果首尾字符串相同，即s[start] = s[end] 那么最长回文子序列就等于dp[start+1][end-1] + 2</p><p>如果首尾字符串不同，那么最长回文子序列就在dp[start+1][end]和dp[start][end-1]之间</p><p>状态初始条件：$$dp[start][end]=1 ， start=end$$状态转移方程：$$ dp[start][end]=dp[start+1][end-1] + 2 , if（str[start]==str[end]） $$$$ dp[start][end]=max(dp[start+1][end], dp[start][end-1]) , if（str[start]！=str[end]） $$</p><p>注意：</p><ol><li>当start == end时，dp[start][end]=1,即它本身</li><li>end 应该大于等于start</li><li>最重要的是要考虑start和end循环的方向，由于dp[start][end]和dp[start+1][end]、dp[start][end-1]、dp[start+1][end-1]有关系，我们可以得出结论是start是从大到小进行循环，end是从小到大进行循环</li></ol><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[start][start] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(start+<span class="number">1</span>, n, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[start] == s[end]:</span><br><span class="line">                dp[start][end] = dp[start+<span class="number">1</span>][end<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                dp[start][end] = max(dp[start+<span class="number">1</span>][end], dp[start][end<span class="number">-1</span>])</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line">print(sol(<span class="string">'abcdfcba'</span>))</span><br></pre></td></tr></table></figure></p><hr><h3>回文子序列个数</h3><blockquote><p>题目要求：给定字符串，求它的回文子序列个数。回文子序列反转字符顺序后仍然与原序列相同。例如字符串aba中，回文子序列为&quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;b&quot;, &quot;aba&quot;，共5个。内容相同位置不同的子序列算不同的子序列。</p></blockquote><p>解题思路：动态规划对于任意字符串，如果头尾字符不相等，则字符串的回文子序列个数就等于去掉头的字符串的回文子序列个数+去掉尾的字符串的回文子序列个数-去掉头尾的字符串的回文子序列个数；</p><p>如果头尾字符相等，那么除了上述的子序列个数之外，还要加上首尾相等时新增的子序列个数，<strong>1+去掉头尾的字符串的回文子序列个数</strong>，1指的是加上头尾组成的回文子序列，如aa，bb等。</p><p>状态初始条件：$$dp[start][end]=1 ， start=end$$状态转移方程：$$ dp[start][end]=dp[start+1][end] + dp[start][end-1]-dp[start+1][end-1]+dp[start+1][end-1] + 1==dp[start+1][end] + dp[start][end-1] + 1, if（str[start]==str[end]） $$$$ dp[start][end]=dp[start+1][end] + dp[start][end-1]-dp[start+1][end-1] , if（str[start]！=str[end]） $$</p><ol><li>当start == end时，dp[start][end]=1,即它本身</li><li>end 应该大于等于start</li><li>start依然是从大到小进行循环，end依然是从小到大进行循环</li></ol><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[start][start] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(start+<span class="number">1</span>, n, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[start] == s[end]:</span><br><span class="line">                dp[start][end] = dp[start+<span class="number">1</span>][end]+ dp[start][end<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                dp[start][end] = dp[start+<span class="number">1</span>][end]+ dp[start][end<span class="number">-1</span>] -dp[start+<span class="number">1</span>][end<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line">print(sol(<span class="string">'xxy'</span>))</span><br></pre></td></tr></table></figure></p><hr><h3>最大回文子串的长度 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">leetcode</a></h3><blockquote><p>题目要求：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 长度最长为1000。示例：</p><blockquote><p>输入: &quot;babad&quot;输出：&quot;bab&quot;注意: &quot;aba&quot;也是有效答案</p></blockquote></blockquote><p>解题思路：</p><p>1.最快的方法：O(N)  --- 经典的'马拉车算法'</p><p><a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">详细请点击</a></p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    ss = <span class="string">'$#'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        ss += i</span><br><span class="line">        ss += <span class="string">'#'</span></span><br><span class="line">    <span class="keyword">return</span> ss</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Manacher</span><span class="params">(s)</span>:</span></span><br><span class="line">    ss = sol(s)</span><br><span class="line">    n = len(ss)</span><br><span class="line">    p = [<span class="number">0</span>]*n</span><br><span class="line">    idd = <span class="number">0</span></span><br><span class="line">    mx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i &lt; mx:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span>*idd - i &gt;<span class="number">-1</span>:</span><br><span class="line">                </span><br><span class="line">                p[i] = min(p[<span class="number">2</span>*idd-i], mx-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p[i] = mx-i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i+p[i]&lt;n <span class="keyword">and</span> i-p[i]&gt;=<span class="number">0</span>) <span class="keyword">and</span>  ss[i+p[i]] == ss[i-p[i]]:</span><br><span class="line">            p[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p[i] + i &gt; mx:</span><br><span class="line">            mx = p[i]+i</span><br><span class="line">            idd = i</span><br><span class="line">    <span class="keyword">return</span> max(p)<span class="number">-1</span></span><br><span class="line">   </span><br><span class="line">print(Manacher(<span class="string">'zedyxabaxy'</span>))</span><br></pre></td></tr></table></figure></p><p>解题思路：</p><p>2.动态规划：O(N^2)</p><p>start &gt;= end</p><p>状态初始条件：$$dp[start][end]=True ， start=end$$状态转移方程：$$ dp[start][end]= str[start] == str[end] end-strart=1 $$</p><p>$$ dp[start][end]= str[start]==str[end]* And * dp[start+1][end-1]  end - start&gt;1  $$</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [[<span class="keyword">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[i][i] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> j-i == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> &lt;= j<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> (dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="comment">#print(dp)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j-i+<span class="number">1</span> &gt;maxx:</span><br><span class="line">                maxx = j-i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxx            </span><br><span class="line">print(sol(<span class="string">'xdadadxy'</span>))</span><br></pre></td></tr></table></figure></p><hr><h3>回文链表 <a href="https://blog.csdn.net/liujunyang0926/article/details/53207216" target="_blank" rel="noopener">原链接</a></h3><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-1.png" alt="4.10-1"></p><p>解题思路：</p><p>仔细观察一个回文比如：1 2 3 4 5 5 4 3 2 1发现有什么规律？假象把这个链表对折，那么相应的每个对称的数字都对的上（这不废话~），其实这个对折过程就是先把链表的一半（前一半后一半都行）反转然后在匹配的过程，如果是回文当然能一一对应上啦</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-2.png" alt="4.10-2"></p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-3.png" alt="4.10-3"></p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.10/4.10-4.png" alt="4.10-4"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回文串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法基础--各种排序算法的性质</title>
      <link href="/2018/01/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2018/01/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      <content type="html"><![CDATA[<table><thead><tr><th>算法种类</th><th>最好情况</th><th>平均情况</th><th>最坏情况</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>是</td></tr><tr><td>冒泡排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>是</td></tr><tr><td>简单选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>否</td></tr><tr><td>希尔排序</td><td></td><td></td><td></td><td>O(1)</td><td>否</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>否</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>否</td></tr><tr><td>2-路归并</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>是</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(r)</td><td>是</td></tr></tbody></table><h2>快速排序</h2><p>快速排序是每趟都确定一个元素的位置，并且在它的位置左边的都比它小，在它右边的都比它大。</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void QuickSort(ElemType A[], int low, int high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        int pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition(ElemType A[], int low, int high)&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high] &gt; pivot) high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low] &lt; pivot) low++;</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>堆排序</h2><p>堆排序是先要构建成大顶堆，而后依次将root跟二叉树最后一个元素互换，每次互换后都要将二叉树再调整回大顶堆。</p><p>下面是建立大顶堆的过程：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; A[<span class="number">0</span>])</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是堆排序算法：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);</span><br><span class="line">    <span class="keyword">for</span>(i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        Swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        AdjustDown(A, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>堆支持删除和插入操作。删除堆顶元素时先将堆顶元素与最后一个元素互换，之后进行向下调整。插入元素时，直接将元素插入到最后的位置，之后进行向上调整。下面是执行向上调整的函数：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(ElemType A[], <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//参数k为向上调整的结点，也就是堆中的元素个数</span></span><br><span class="line">    A[<span class="number">0</span>] = A[k];</span><br><span class="line">    <span class="keyword">int</span> i = k / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;A[<span class="number">0</span>])&#123;</span><br><span class="line">        A[k] = A[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>简单选择排序</h2><p>假设排序表为L[1...n]，第i趟排序即从L[1...n]中选择关键字最小的元素与L[i]进行交换，每一趟排序都可以确定一个元素的最终位置，经过n-1趟排序就可以使整个排序表有序。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">            Swap(A[i], A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python基础--pandas包和sklearn包的方法整理</title>
      <link href="/2017/09/03/python%E5%9F%BA%E7%A1%80--pandas%E5%8C%85%E5%92%8Csklearn%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2017/09/03/python%E5%9F%BA%E7%A1%80--pandas%E5%8C%85%E5%92%8Csklearn%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h1>python基础--pandas包和sklearn包的方法整理</h1><hr><p>pandas的操作：</p><p>1.pandas读取txt：https://segmentfault.com/q/1010000012437263</p><p>2.pandas获取datetime的days，months，years：http://www.jb51.net/article/105840.htm</p><p>3.pandas看有多少个不重复的用户：https://blog.csdn.net/jasonwang_/article/details/78984852</p><p>4.kaggle预测房价：https://www.leiphone.com/news/201704/Py7Mu3TwRF97pWc7.html</p><p>5.删除某些属性为x的行：a = df[(True^df['value'].isin([3]))]  ##删除表df中value属性为3的行index重置：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span><span class="params">()</span>:</span>  </span><br><span class="line">    obj3 = Series([<span class="string">'blue'</span>, <span class="string">'purple'</span>, <span class="string">'yellow'</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])  </span><br><span class="line">    <span class="keyword">print</span> obj3  </span><br><span class="line">    obj4 = obj3.reset_index(drop=<span class="keyword">True</span>)  </span><br><span class="line">    <span class="keyword">print</span> obj4  </span><br><span class="line">    <span class="keyword">print</span> type(obj4)</span><br></pre></td></tr></table></figure></p><p>6.pandas.DataFrame.drop_duplicates后面inplace=True与inplace=False的区别：</p><blockquote><p>drop_duplicates(inplace=True)是直接对原dataFrame进行操作。如:t.drop_duplicates(inplace=True) 则，对t中重复将被去除。drop_duplicates(inplace=False)将不改变原来的dataFrame，而将结果生成在一个新的dataFrame中。如：s = t.drop_duplicates(inplace=False)则，t的内容不发生改变，s的内容是去除重复后的内容</p></blockquote><p>7.pandas填充缺失值：</p><blockquote><p>填充缺失数据 fillna常数调用df.fillna(0)字典调用，对不同的列填充不同的值df.fillna({1:0.5, 3:-1})fillna默认会返回新对象！！，就地修改： _ = df.fillna(0,inplace=True)对reindex有效的插值方法也可用于fillna</p></blockquote><p>8.判断df中是否有缺失值：df.isnull().any()</p><p>9.删除pandas DataFrame的某一/几列：</p><blockquote><p>方法一：直接del DF['column-name']方法二：采用drop方法，有下面三种等价的表达式：</p><ol><li>DF= DF.drop('column_name', 1)；</li><li>DF.drop('column_name',axis=1, inplace=True)</li><li>DF.drop(DF.columns[ : ], axis=1,inplace=True)  #Note:zero indexed注意：凡是会对原数组作出修改并返回一个新数组的，往往都有一个 inplace可选参数。如果手动设定为True（默认为False），那么原数组直接就被替换。也就是说，采用inplace=True之后，原数组名（如2和3情况所示）对应的内存值直接改变；而采用inplace=False之后，原数组名对应的内存值并不改变，需要将新的结果赋给一个新的数组或者覆盖原数组的内存位置（如1情况所示）。</li></ol></blockquote><p>10.表格合并：  https://www.cnblogs.com/bigshow1949/p/7016245.html</p><blockquote><p>缺失值处理方法：填0 丢弃 找规律填值（中位数，平均数）处理缺失值第一种方法 ： 丢弃f.dropna(inplace=True)第二种方法 ：  填0f.fillna(0, inplace=True)第三种方法 ：  找规律</p></blockquote><p>11.按某一列的值进行排序：d = df.sort_values(by=['value'], ascending=False)ascending=False 降序  True升序</p><p>12.用pandas中的DataFrame时选取行或列: https://blog.csdn.net/wanglingli95/article/details/78887771</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>),index=list(<span class="string">'abcd'</span>),columns=list(<span class="string">'wxyz'</span>))</span><br><span class="line"></span><br><span class="line">data[<span class="string">'w'</span>]  <span class="comment">#选择表格中的'w'列，使用类字典属性,返回的是Series类型</span></span><br><span class="line"></span><br><span class="line">data.w    <span class="comment">#选择表格中的'w'列，使用点属性,返回的是Series类型</span></span><br><span class="line"></span><br><span class="line">data[[<span class="string">'w'</span>]]  <span class="comment">#选择表格中的'w'列，返回的是DataFrame属性</span></span><br><span class="line"></span><br><span class="line">data[[<span class="string">'w'</span>,<span class="string">'z'</span>]]  <span class="comment">#选择表格中的'w'、'z'列</span></span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment">#返回第1行到第2行的所有行，前闭后开，包括前不包括后</span></span><br><span class="line"></span><br><span class="line">data[<span class="number">1</span>:<span class="number">2</span>]  <span class="comment">#返回第2行，从0计，返回的是单行，通过有前后值的索引形式，</span></span><br><span class="line">       <span class="comment">#如果采用data[1]则报错</span></span><br><span class="line"></span><br><span class="line">data.ix[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">#返回第2行的第三种方法，返回的是DataFrame，跟data[1:2]同</span></span><br></pre></td></tr></table></figure></p><p>13.pandas 一列转list<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'a'</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],</span><br><span class="line">                   <span class="string">'b'</span>:[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'a'</span>].values.tolist()</span><br><span class="line">也可以用df[<span class="string">'a'</span>].tolist()</span><br><span class="line">结果：  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><p>14.pandas 数据类型 ：df['a'].dtypes<br>list 中的数据类型： type(a[0])</p><p>15.重命名pandas：train1.rename(columns={'9_yue_end':'label'}, inplace=True)16.列合并：all_feature = pd.merge(all_feature, fe, how='left', on=['user'])行合并：pd.concat</p><p>17.pandas判断缺失值一般采用 isnull()pandas 空值定义为numpy.nan</p><p>18.对整体的series或Dataframe判断是否未空，用isnull()</p><blockquote><p>eg: pd.isnull(df1) #df1是dataframe变量</p></blockquote><p>19.对单独的某个值判断，可以用 np.isnan()</p><blockquote><p>eg: np.isnan(df1.ix[0,3]) #对df1的第0行第3列判断</p></blockquote><p>20.查找list中元素的index：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=list.index(value)</span><br><span class="line"></span><br><span class="line">list为列表的名字</span><br><span class="line"></span><br><span class="line">value为查找的值</span><br><span class="line"></span><br><span class="line">p为value在list的位置</span><br></pre></td></tr></table></figure></p><p>31.sklearn的归一化：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]</span><br><span class="line">print(data)</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">print(scaler.fit(data))</span><br><span class="line">print(scaler.mean_)</span><br><span class="line">print(scaler.transform([[<span class="number">2</span>, <span class="number">2</span>]]))</span><br><span class="line">print(scaler.inverse_transform([[<span class="number">-1.22474487</span>],[<span class="number">0.0</span>],[<span class="number">1.22474487</span>]]))</span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">StandardScaler(copy=<span class="keyword">True</span>, with_mean=<span class="keyword">True</span>, with_std=<span class="keyword">True</span>)</span><br><span class="line">[ <span class="number">2.</span>]</span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>]]</span><br><span class="line">[[ <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span>]]</span><br></pre></td></tr></table></figure></p><p>32.标准化，one-hot等：https://www.cnblogs.com/jcchoiling/p/8876073.html</p>]]></content>
      
      
        <tags>
            
            <tag> python基础 </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习--keras中image.ImageDataGenerator.flow_from_directory()方法</title>
      <link href="/2017/07/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--keras%E4%B8%ADimage.ImageDataGenerator.flow_from_directory()%E6%96%B9%E6%B3%95/"/>
      <url>/2017/07/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--keras%E4%B8%ADimage.ImageDataGenerator.flow_from_directory()%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>作用：keras中image.ImageDataGenerator.flow_from_directory()方法可以实现从文件夹中提取图片和进行简单归一化处理。</p></blockquote><blockquote><p>keras中有很多封装好的API可以帮助我们实现对图片数据的读取和处理。比如 ： keras.preprocessing.image.ImageDataGenerator.flow_from_directory( ) 这个函数这个函数的参数包括：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">flow_from_directory(self, directory,  </span><br><span class="line">                            target_size=(<span class="number">256</span>, <span class="number">256</span>), color_mode=<span class="string">'rgb'</span>,  </span><br><span class="line">                            classes=<span class="keyword">None</span>, class_mode=<span class="string">'categorical'</span>,  </span><br><span class="line">                            batch_size=<span class="number">32</span>, shuffle=<span class="keyword">True</span>, seed=<span class="keyword">None</span>,  </span><br><span class="line">                            save_to_dir=<span class="keyword">None</span>,  </span><br><span class="line">                            save_prefix=<span class="string">''</span>,  </span><br><span class="line">                            save_format=<span class="string">'jpeg'</span>,  </span><br><span class="line">                            follow_links=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p></blockquote><p>flow_from_directory(directory): 以文件夹路径为参数,生成经过数据提升/归一化后的数据,在一个无限循环中无限产生batch数据</p><p>directory: 目标文件夹路径,对于每一个类,该文件夹都要包含一个子文件夹.子文件夹中任何JPG、PNG、BNP、PPM的图片都会被生成器使用.详情请查看此脚本target_size: 整数tuple,默认为(256, 256). 图像将被resize成该尺寸</p><p>color_mode: 颜色模式,为”grayscale”,”rgb”之一,默认为”rgb”.代表这些图片是否会被转换为单通道或三通道的图片.</p><p>classes: 可选参数,为子文件夹的列表,如[‘dogs’,’cats’]默认为None. 若未提供,则该类别列表将从directory下的子文件夹名称/结构自动推断。每一个子文件夹都会被认为是一个新的类。(类别的顺序将按照字母表顺序映射到标签值)。通过属性class_indices可获得文件夹名与类的序号的对应字典。</p><p>class_mode: “categorical”, “binary”, “sparse”或None之一. 默认为”categorical. 该参数决定了返回的标签数组的形式, “categorical”会返回2D的one-hot编码标签,”binary”返回1D的二值标签.”sparse”返回1D的整数标签,如果为None则不返回任何标签, 生成器将仅仅生成batch数据, 这种情况在使用model.predict_generator()和model.evaluate_generator()等函数时会用到.</p><p>batch_size: batch数据的大小,默认32</p><p>shuffle: 是否打乱数据,默认为True</p><p>seed: 可选参数,打乱数据和进行变换时的随机数种子</p><p>save_to_dir: None或字符串，该参数能让你将提升后的图片保存起来，用以可视化save_prefix：字符串，保存提升后图片时使用的前缀, 仅当设置了save_to_dir时生效save_format：”png”或”jpeg”之一，指定保存图片的数据格式,默认”jpeg”flollow_links: 是否访问子文件夹中的软链接</p><p>使用flow_from_directory最值得注意的是directory这个参数：</p><p>directory: path to the target directory. It should contain one subdirectory per class. Any PNG, JPG, BMP, PPM or TIF images inside each of the subdirectories directory tree will be included in the generator.</p><p>这是官方文档的定义，它的目录格式一定要注意是包含一个子目录下的所有图片这种格式，driectoty路径只要写到标签路径上面的那个路径即可。</p><p>target_size：可是实现对图片的尺寸转换，是预处理中比较常用的方法</p><p>save_to_dir: 可以设置保存处理后图片的路径。</p><p>save_prefix: 可以对处理后图片设置前缀。</p>]]></content>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> keras </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络安全--日志分析：报警关联</title>
      <link href="/2017/07/03/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8--%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%EF%BC%9A%E6%8A%A5%E8%AD%A6%E5%85%B3%E8%81%94/"/>
      <url>/2017/07/03/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8--%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%EF%BC%9A%E6%8A%A5%E8%AD%A6%E5%85%B3%E8%81%94/</url>
      <content type="html"><![CDATA[<h2>网络安全--日志分析：报警关联</h2><hr><p>警关联分析技术对以入侵报警信息为主的安全报警进行组合、解释和分析。目标是对报警信息的求精，以对攻击规划进行识别和场景重构。报警关联是一个过程，分析了由一个或多个入侵检测系统产生的警报，提供了更加简洁和高层次的入侵或企图侵入的判断。尽管关联过程往往是由一个步骤提出，分析实际通过若干组成部分协作完成，各自有具体的目标。通过对来自于不同类型IDS和其他安全设备所产生的报警进行聚合与关联，可以有效地解决入侵检测分类技术由于硬件速度、算法假设和复杂网络环境的影响所很难克服的误报和漏报偏高等问题，为自动、深入的报警处理打下基础，可以实现如下目标：</p><blockquote><ul><li>1.消除或减少重复报警。网络上不同的IDS 针对同一个安全事件都可能报警，即使是同一个 IDS也可能对某个安全事件发出多个报警。这些重复报警少则几个，多则上万。通过对报警的聚合，可以大大减少重复报警率。</li></ul></blockquote><hr><blockquote><ul><li>2.降低误报率。通过将一个攻击过程相关报警信息关联在一起，可以消除某些孤立和随机事件产生的误报警。另外，报警信息同被保护网络系统本身的信息相互比对就可以很好地滤除无关报警，降低误报率。</li></ul></blockquote><hr><blockquote><ul><li>降低漏报率。目前，没有一种单一的 IDS 能够检测到所有网络攻击。不同 IDS 之间的报警通过关联，可以相互补充，防止漏报的发生。</li></ul></blockquote><hr><blockquote><ul><li>3.发现高层攻击策略。将入侵过程的一系列攻击活动关联在一起，重建攻击过程，这样就可以对入侵的整体情况进行描述，有利于对入侵的理解，发现攻击策略，克服了以往IDS那种检测结果过于细化和底层缺点，为人侵的意图识别、入侵行动预测和入侵响应打下了基础。</li></ul></blockquote><hr><blockquote><ul><li>4.扩大了IDS的检测范围。在较大型的交换式网络统中，单个的IDS(不论是基于网络的还是基于主机的)其检测范围和处理能力是有限的，要想掌握整个网络的安全情况，就要将多个 IDS和安全设备布置在网络上的不同位置，然后将来自于这些安全设备的报警进行融合处理，从而实现全网范围内的安全防御。</li></ul></blockquote><hr><p>目前已经提出的入侵报警关联分析方法，主要可以分为报警聚类方法、基于攻击规划库的报警关联方法和基于攻击行为建模的报警关联方法三大类。</p><h5>报警聚类方法</h5><blockquote><p>1.报警聚类方法属于最初步的关联分析，通过报警属性值之间的相似性对报警进行聚类，使得同个聚类的报警集合具有某些相同的特性，然后选择一个抽象的“元报警”事件作为该聚类的代表元。此类方法不能够完全揭示出相关报警之间的因果联系，无法对报警反映的攻击场景给出清晰的解释，也无法预测攻击者的目标和进一步的攻击规划。</p></blockquote><h5>基于攻击规划库的报警关联方法</h5><blockquote><p>2.基于攻击规划库的报警关联方法在拥有一个完整的已知攻击规划库的基础上，通过一系列关联分析技术来识别报警流中包含的与攻击规划库中的攻击规划相一致的攻击场景实例。基于攻击规划库的报警关联方法是基于封闭世界假说，需要一个完整的攻击规划库作为支撑基础，但在实际环境中，由于攻击动作的多样性和攻击过程的随意性以及新的攻击工具和技术的不断出现，使得构建一个完善的攻击规划库极为困难。此外，由于存在并行的攻击场景，上述的各种方法对每个攻击场景维护中间的状态，从而导致其存储代价和计算代价都非常庞大。上述两个缺陷使得基于攻击场景库的报警关联方法难以在实际中得到广泛的有效应用。</p></blockquote><h5>基于攻击行为建模的报警关联方法</h5><blockquote><p>3.基于攻击行为建模的报警关联方法通过对攻击动作的前提条件和造成的后果进行描述，构建攻击模型，如果一个攻击动作的后果使得另一攻击动作的前提条件得到满足，则认为这两个攻击动作之间存在因果关系。基于攻击行为建模的报警关联算法就利用这些因果关系将观察到的报警进行连接，构造出整个攻击场景。基于攻击行为建模的报警关联方法不需要对所有可能的攻击规划进行描述和存储，只需要对单个攻击行为动作进行建模，准确刻画其所需的前提条件和造成的后果，因此攻击知识模型的构建和维护较为可行，另外构建的攻击知识模型存在较强的灵活性，能够对一些未知的攻击场景进行识别。</p></blockquote><p>现有的入侵报警关联分析技术还存在着如下一些问题：</p><ul><li>[ ]  首先，能够完成攻击规划识别的关联分析技术都需要有一个领域知识库的支撑，虽然目前在攻击关联知识模型方面有一些研究工作，但目前尚未有完整的、实际可行的网络攻防知识库的构建方案。攻防知识库构建的困难阻碍了关联分析技术的实际应用；</li><li>[ ]  其次，现有的入侵报警关联分析技术大多仅仅根据固定的模式对报警进行关联，而未对受监控系统以及攻击者的状态进行有效跟踪；</li><li>[ ]  第三，缺乏对攻击者意图的识别，无法为正确及时的响应提供支持；最后，由于在实际网络环境中很难获得攻击场景测试数据并准确地从背景网络流量中对其进行正确标识，因此对入侵报警关联分析技术的测试和验证普遍缺乏足够的攻击场景数据，这也使得目前大多数的入侵报警关联分析技术研究仅仅针对几个人工构造的攻击场景数据集，并不能够体现实用性。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 日志分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--参数模型和无参数模型的区别</title>
      <link href="/2017/04/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%97%A0%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/04/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%97%A0%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1>机器学习--参数模型和无参数模型的区别</h1><hr><p>在统计学中，参数模型通常假设总体（随机变量）服从某一个分布，该分布由一些参数确定（比如正太分布由均值和方差确定），在此基础上构建的模型称为参数模型；非参数模型对于总体的分布不做任何假设，只是知道总体是一个随机变量，其分布是存在的（分布中也可能存在参数），但是无法知道其分布的形式，更不知道分布的相关参数，只有在给定一些样本的条件下，能够依据非参数统计的方法进行推断。</p><p>从上述的区别中可以看出，问题中有没有参数，并不是参数模型和非参数模型的区别。其区别主要在于总体的分布形式是否已知。而为何强调“参数”与“非参数”，主要原因在于参数模型的分布可以有参数直接确定。</p><p><img src="https://github.com/Buevara/blog_img/raw/master/4.26/4.26-1.png" alt="4.26-1"><img src="https://github.com/Buevara/blog_img/raw/master/4.26/4.26-2.png" alt="4.26-2"></p><p>###参数机器学习算法</p><blockquote><p>假设可以最大程度地简化学习过程，与此同时也限制可以学习到是什么。这种算法简化成一个已知的函数形式，这称为参数机器学习算法。</p></blockquote><p>这种算法包括两种步骤：     1. 选择一种目标函数的形式；     2. 从训练数据中学习目标函数的系数。  一种最容易理解目标（映射）函数的形式就是一条直线，用于线性回归：此处的、和是直线的系数，用于控制直线的截距和斜率，和是两个输入变量。把目标函数的形式假设为一条直线大大简化了学习过程。现在，我们需要做的是估计这个直线等式的系数，和有一个预测模型的问题。  通常假设函数的形式是一个输入变量的线性组合，因此这种参数机器学习算法经常也称为“线性机器学习算法”。  问题是，实际的未知潜在函数可能不是一个线性函数，比如一条直线。它 可能接近一条直线和需要一些细微的输入调整。或者可能不像一条直线，在这种情况下，假设就是错误的，这种方法将会产生很差的结果。参数机器学习算法的一些常见例子包括：  Logistic Regression,LDA（线性判别分析）,感知机,朴素贝叶斯,简单的神经网络</p><blockquote><p>参数机器学习算法的优点：简单：这些算法很容易理解和解释结果；快速：参数模型可以很快从数据中学习；少量的数据：它们不需要太多的训练数据，甚至可以很好地拟合有缺陷的数。参数机器学习算法的局限性：约束：这些算法选择一种函数形式高度低限制模型本身；有限的复杂性：这种算法可能更适合简单的问题；不适合：在实践中，这些方法不太可能匹配潜在的目标（映射）函数。</p></blockquote><hr><p>###非参数机器学习算法</p><blockquote><p>不对目标函数的形式作出强烈假设的算法称为非参数机器学习算法。通过不做假设，它们可以从训练数据中自由地学习任何函数形式。</p></blockquote><p>在构造目标函数时，非参的方法寻找最合适的训练数据，同时保留一些对不可见数据的泛化能力。因此，这些非参方法能够拟合大多数的函数形式。  一种理解非参模型的最好例子是KNN算法，对于一个新的数据实例，KNN基于K个最相似的训练模式（已标记的实例）。这种方法除了模式可能更接近有一个相似的输出变量之外，不需要对目标函数的形式作出任何的假设。  非参数机器学习算法的一些常见例子包括：  KNN,决策树,比如CART和C4.5,SVM</p><blockquote><p>非参数机器学习算法的优点：灵活性：拟合大量的不同函数形式；能力：关于潜在的函数不需要假设（或者若假设）；性能：可以得到用于预测的高性能模型。  非参数机器学习算法的局限性：更多的数据：需要更多的训练数据用于估计目标函数；慢：训练很慢，因为它们常常需要训练更多的参数；过拟合：更多的过度拟合训练数据风险，同时它更难解释为什么要做出的具体预测。</p></blockquote><hr>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习--机器学习与数学基础笔记整理</title>
      <link href="/2017/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
      <url>/2017/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2>机器学习</h2><h3>什么是机器学习？</h3><blockquote><p>对于某给定的任务T，在合理的性能度量方案P的前提下，某计算机程序可以自主学习任务T的经验E；随着提供合适、优质、大量的静安E，改程序对于任务T的性能逐步提交。</p></blockquote><h3>这个任务最重要的是机器学习的对象：</h3><blockquote><p>任务Task，T，一个或者多个经验Experience，E性能Performance，P</p></blockquote><p>总结来说：就是随着任务的不断执行，经验的累计会带来计算性能的提升。</p><h3>机器学习的一般流程</h3><blockquote><ol><li><em>数据收集</em></li><li><em>数据清洗</em></li><li><em>特征工程</em></li><li><em>数据建模</em></li></ol></blockquote><p>注意：</p><ol><li>数据直接影响学习的结果。</li><li>对特征的选取不同，所得到的结果也会不同。</li><li>对于模型的选择，也有不同的方案，同样的数据用不同的模型所得到的结果不同。</li></ol><h2>机器学习的数学基础</h2><h3>高等数学</h3><ul><li>导数</li></ul><blockquote><p>简单来说，导数是曲线的斜率，是曲线变化快慢的反应<strong>二阶导数</strong>是斜率变化快慢的反应，表征曲线<strong>凹凸性</strong>根据$\lim_{x\rightarrow \infty }(1+\frac{1}{x})^{x}=e$，可以得到函数$ f(x)=lnx $的导数，进一步根据换底公式/反函数求导等，得到其他初等函数的导数。常用函数的导数$ {C}'=0$       ${({x}<sup>n)}'=nx</sup>{n-1} $$ {sinx}'=cosx$    ${cosx}'=-sinx $$ {(a<sup>{x})}'=a</sup>{x}lna$    ${(e<sup>x)}'=e</sup>x $$ {(log_{a}x)}'=\frac{1}{x}{log_{a}e}$ ${(lnx)}'=\frac{1}{x} $$ {(u+v)}'=u'+v'$ ${(uv)}'=u'v+uv' $</p></blockquote><p>例子：已知$ f(x)=x^x,x&gt;0 $，求解其最小值</p><blockquote><p>$ t=x^x $$ lnt=xlnx $两边对x求导:$ \frac{1}{t}t'=lnx+1 $令$ t'=0$:$lnx+1=0 $$ x=(e)^{-1} $$ t=e^{-\frac{1}{e}} $</p></blockquote><p>例子：推导$ N\rightarrow \infty \Rightarrow lnN!\rightarrow N(lnN-1) $</p><blockquote><p>$ lnN!=\sum_{i=1}^{N}lni\approx \int_{1}^{N}lnxdx $$ =xlnx|<em>{1}<sup>{N}-\int_{1}</sup>{N}xdxlnx $$ =NlnN-\int</em>{1}^{N}x\cdot \frac{1}{x}dx $$ =NlnN-x|_{1}^{N} $$ =NlnN-N+1 $$ \rightarrow NlnN-N $</p></blockquote><ul><li>Tayor公式</li></ul><blockquote><p>$ f(x)=f(x_{0})+f'(x_{0})(x-x_{0})+\frac{f''(x_{0})}{2!}(x-x_{0})+...+\frac{f<sup>{(n)}(x_{0})}{n!}(x-x_{0})</sup>{n}+R_{n}(x) $令x=0，得到：$ f(x)=f(0)+f'(0)x+\frac{f''(0)}{2!}x<sup>{2}+...+\frac{f</sup>{n}(0)}{n!}x<sup>{n}+o(x</sup>{n}) $</p></blockquote><p>Taylor公式的应用：数值计算：初等函数值计算（在原点上展开）</p><blockquote><p>$$ sinx=x-\frac{x<sup>{3}}{3!}+\frac{x</sup>{5}}{5!}-\frac{x<sup>{7}}{7!}+\frac{x</sup>{9}}{9!}+...+(-1)<sup>{m-1}\frac{x</sup>{2m-1}}{(2m-1)!}+R_{2m} $$$$ e<sup>{x}=1+x+\frac{x</sup>{2}}{2!}+\frac{x<sup>{3}}{3!}+\frac{x</sup>{4}}{4!}+...+\frac{x^{n}}{n!}+R_{n} $$</p></blockquote><p>在实践中，往往需要做一定程度上的变换。</p><p>例子：计算$ e^{x} $</p><blockquote><p>$ x=k\cdot ln2+r $ , $ \left | r \right |\leqslant 0.5\cdot ln2 $$$e<sup>{x}=e</sup>{k\cdot ln2+r}=e^{k\cdot ln2}\cdot e^{r} =2^{k}\cdot e^{r}$$</p></blockquote><ul><li>方向导数</li></ul><blockquote><p>如果函数$ z=f(x,y) $在点$ P(x,y) $是可微分的，那么，函数在该点沿任意方向$ L $的方向导数都存在，且有：$ \frac{\partial f}{\partial l}=\frac{\partial f}{\partial x}cos\varphi +\frac{\partial f}{\partial y}sin\varphi $其中，$ \varphi $为x轴到方向L的转角。</p></blockquote><ul><li>梯度</li></ul><blockquote><p>设函数$ z=f(x,y) $在平面区域D内具有一阶连续偏导数，则对于每一个点$P(x,y)\in D$,向量$$ (\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}) $$为函数$ z=f(x,y) $在点$P(x,y)$的梯度，记作$ gradf(x) $梯度的方向是函数在该点变化最快的方向</p></blockquote><p>###概率论</p><blockquote><ul><li>概率表达式：$ P(x)\in [0,1] $若x为离散，则$ P(x=x_{0}) $表示$ x_{0} $发生的<em>概率</em>若x为连续变量，则$ P(x=x_{0}) $表示$x_{0}$发生的<em>概率密度</em></li><li>累计分布函数：$ \Phi (x)=P(x\leq x_{0}) $$ \Phi (x) $一定为<em>单调递增函数</em>。$ min(\Phi (x))=0 $,$ max(\Phi (x))=1 $</li></ul></blockquote><p>思考：将值域为[0,1]的单增函数$ y=F(x) $看成<strong>X事件的累积概率函数</strong>，若$y=F(x)$可导，则$f(x)=F'(x)$为概率密度函数</p><blockquote><ul><li>概率公式条件概率：$ P(A|B)=\frac{P(AB)}{P(B)} $全概率公式：$ P(A)=\sum_{i}P(A|B_{i})P(B_{i}) $贝叶斯(Bayes)公式：$ P(B_{i}|A)=\frac{P(A|B_{i})P(B_{i})}{\sum_{j}P(A|B_{i})P(B_{j})} $</li></ul></blockquote><blockquote><ul><li>贝叶斯公式：<img src="http://osibywvsl.bkt.clouddn.com/bayes%E5%85%AC%E5%BC%8F.png" alt=""></li></ul></blockquote><blockquote><ul><li>分布<img src="http://osibywvsl.bkt.clouddn.com/%E5%90%84%E7%A7%8D%E5%88%86%E5%B8%83.png" alt=""></li></ul></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
